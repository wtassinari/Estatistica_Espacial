---
title: "Especializa√ß√£o em Estat√≠stica Aplicada (PPGEAD): M√≥dulo de Estat√≠stica Espacial"
author: |
  | Wagner Tassinari 
  |
date: "2025"
output:
  rmdformats::robobook:
    css: style.css
    highlight: kate
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
knitr::opts_chunk$set(echo=FALSE,
               cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               cache.lazy=FALSE)
knitr::opts_knit$set(width=75)

```

```{r klippy}
# Insert copy to clipboard buttons in HTML documents
# remotes::install_github("rlesur/klippy")
# xfun::install_github("rlesur/klippy")
# remotes::install_github("spatstat/spatstat.core")
klippy::klippy(
  lang = c("r", "markdown"),
  all_precode = FALSE,
  position = c("top", "right"),
  color = "navyblue",
  tooltip_message = "copiar c√≥digo",
  tooltip_success = "copiado!"
)

```

```{r}
## Color Format
colFmt <- function(x,color) {
  
  outputFormat <- knitr::opts_knit$get("rmarkdown.pandoc.to")
  
  if(outputFormat == 'latex') {
    ret <- paste("\\textcolor{",color,"}{",x,"}",sep="")
  } else if(outputFormat == 'html') {
    ret <- paste("<font color='",color,"'>",x,"</font>",sep="")
  } else {
    ret <- x
  }

  return(ret)
}
```


```{r echo=F, fig.align="center", out.width="90%", fig.asp=0.5}

include_graphics('figuras/rural2.png')
```

Fonte: [Storymap UFRRJ](https://uploads.knightlab.com/storymapjs/900b7a9343559e19eae3c9dffed08d71/ufrrj/draft.html)



# Introdu√ß√£o √† An√°lise Estat√≠stica Espacial

## O que √© An√°lise Estat√≠stica Espacial ?

- S√£o m√©todos estat√≠sticos que levam em considera√ß√£o a localiza√ß√£o espacial do fen√¥meno estudado;

- Segundo Bailey & Gatrell (1995), *"A an√°lise estat√≠stica espacial √© aplicada quando os dados possuem localiza√ß√£o geogr√°fica e quando o arranjo espacial desses dados √© considerado relevante para a an√°lise e interpreta√ß√£o dos resultados."*

- A primeira quest√£o a ser considerada √©: os dados seguem um padr√£o aleat√≥rio ou indicam a presen√ßa de agrega√ß√µes bem definidas (*clusters*) ?

```{r echo=F, fig.align="center", out.width= "80%", fig.show='hold'}
knitr::include_graphics('figuras/Cluster.png')
```

## Origem da Estat√≠stica Espacial

O uso de dados espaciais na sa√∫de teve um marco hist√≥rico com John Snow, que em 1854 mapeou um surto de c√≥lera em Londres, desafiando a teoria miasm√°tica* ao identificar a contamina√ß√£o da √°gua como causa da doen√ßa. Ao mapear as mortes por c√≥lera no Soho, John Snow identificou um foco ao redor da bomba de √°gua da Broad Street, apoiando sua hip√≥tese de transmiss√£o h√≠drica.

<span style="font-size: 10px;">
*"Miasm√°tica" refere-se √† teoria que defendia que as doen√ßas eram causadas por vapores ou odores nocivos (miasmas) provenientes de mat√©ria org√¢nica em decomposi√ß√£o, particularmente em √°reas √∫midas ou com m√° higiene.
</span>


```{r echo=F, fig.align="center", out.width= "80%", fig.show='hold'}
include_graphics('figuras/snow2_2019.png')
```
<span style="font-size: 11px;">
- Mapeamento dos casos de col√©ra ($\bullet$) e as bombas de √°gua (X) em Londres, 1854.
</span>

- Dr. John Snow (1813-1858) $\rightarrow$ Considerado pai da Epidemiologia Moderna

```{r echo=F, fig.align="center", out.width= "40%", fig.show='hold'}
include_graphics('figuras/snow_2019.png')
```
\

A imagem mostra homenagens a John Snow em Soho, Londres: um retrato na fachada de um pub, a r√©plica da bomba de √°gua da Broad Street, e uma placa que marca a descoberta de que a c√≥lera era transmitida pela √°gua contaminada em 1854.

## Objetivos da Estat√≠stica Espacial

1) Investigar padr√µes espaciais e espa√ßo-temporais, por meio de t√©cnicas como a An√°lise Explorat√≥ria de Dados Espaciais (AEDE) e medidas de correla√ß√£o espacial, visando identificar estruturas, agrupamentos e depend√™ncias nos dados geogr√°ficos.

2) Modelar fen√¥menos espaciais utilizando modelos estat√≠sticos apropriados, como regress√µes espaciais (ex: SAR, CAR, GWR) e modelos espa√ßo-temporais, que permitem controlar efeitos de vizinhan√ßa (depend√™ncia espacial) e heterogeneidade geogr√°fica, com o objetivo de explicar e/ou prever fen√¥menos influenciados pela localiza√ß√£o geogr√°fico.

## Depend√™ncia Espacial ou Autocorrela√ß√£o Espacial

- Segundo Cressie (1991), embora a suposi√ß√£o de independ√™ncia entre observa√ß√µes torne a teoria estat√≠stica mais trat√°vel, modelos que incorporam *depend√™ncia estat√≠stica* costumam ser mais realistas, especialmente em contextos espaciais. Nesse tipo de dado, a *depend√™ncia entre observa√ß√µes ocorre em m√∫ltiplas dire√ß√µes* e tende a diminuir conforme aumenta a dist√¢ncia entre os locais amostrados. Em outras palavras, valores pr√≥ximos no espa√ßo tendem a ser mais semelhantes entre si do que valores distantes, o que caracteriza a autocorrela√ß√£o espacial.

- *"Todas as coisas se parecem, por√©m coisas mais pr√≥ximas tendem a ser mais semelhantes do que aquelas mais distantes."*  (Tobler, 1979). `r colFmt(" **Tamb√©m conhecida como $1^a$ Lei da Geografia**",'red')`

## Tipologia dos Dados Espaciais

Os dados espaciais podem ser classificados segundo diferentes categorias, com base na natureza estoc√°stica de suas observa√ß√µes e na forma como a informa√ß√£o geogr√°fica √© representada. Essa tipologia orienta a escolha de m√©todos estat√≠sticos apropriados para an√°lise.

Segundo Noel Cressie (1993), a estat√≠stica espacial pode ser dividida em tr√™s grandes √°reas:

  i) `r colFmt(" **Dados de Processos Pontuais ou Padr√µes Pontuais**",'darkmagenta')`: As observa√ß√µes ocorrem de maneira aleat√≥ria no espa√ßo, como casos de uma doen√ßa, localiza√ß√£o de crimes ou ocorr√™ncia de focos de queimadas. O objetivo √© entender padr√µes de agrupamento, dispers√£o ou aleatoriedade desses pontos.

  ii) `r colFmt(" **Dados de Geoestat√≠stica**",'darkmagenta')`: Refere-se as observa√ß√µes que apresentam um atributo mensurav√©l em localiza√ß√µes cont√≠nuas ou irregulares (por exemplo, temperatura, polui√ß√£o, altitude, teor de argila). Nesses casos, h√° interesse na depend√™ncia espacial entre valores pr√≥ximos e na interpola√ß√£o de valores para locais n√£o amostrados, por meio de m√©todos como krigagem.

  iii) `r colFmt(" **Dados de √Årea**",'darkmagenta')`: Representam fen√¥menos agregados por unidades geogr√°ficas, como munic√≠pios, distritos ou setores censit√°rios. As an√°lises incluem autocorrela√ß√£o espacial (ex: I de Moran) e modelos de regress√£o espacial adaptados a dados agregados.

<!-- Existem m√©todos estatƒ±ÃÅsticos diferentes para descrever ou analisar estes tipos de dados. Exemplo: -->

<!-- ```{r echo=F, fig.align="center", out.width= "75%", fig.show='hold'} -->
<!-- include_graphics('figuras/slide4.jpg') -->

<!-- ``` -->

# Padr√µes Pontuais

* O principal interesse est√° no conjunto de coordenadas geogr√°ficas representando as localiza√ß√µes exatas de eventos.

```{r echo=F, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="50%", comment=NA}
knitr::include_graphics('figuras/coordenadas.png')
```

## Exemplos de aplica√ß√£o

::: box-dica3
- üè• Localiza√ß√£o de casos de uma doen√ßa notificados em uma cidade.
- üå≥ Distribui√ß√£o espacial de √°rvores em um parque urbano.
- üêæ Registros de avistamentos de animais silvestres em uma reserva.
- üî• Pontos de ocorr√™ncia de focos de inc√™ndio florestal detectados por sat√©lite.
:::

::: box-dica2
Neste tipo de dado, o evento aleat√≥rio de interesse √© a posi√ß√£o espacial onde o fen√¥meno ocorre, e n√£o uma vari√°vel medida em si. A an√°lise busca entender se os pontos seguem um padr√£o aleat√≥rio, agrupado (clusters) ou disperso no espa√ßo.

:::

```{r echo=F, fig.align="center", out.width= "55%", fig.show='hold'}
knitr::include_graphics('figuras/Cluster2.png')
```


```{r echo=F, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="70%", comment=NA}
knitr::include_graphics('figuras/pontos1.jpg')
```


## Estimativas de Kernel (ou Mapas de Calor)

As estimativas de densidade kernel s√£o uma t√©cnica amplamente utilizada para **representar visualmente a concentra√ß√£o espacial de eventos pontuais**, como casos de doen√ßas, crimes ou ocorr√™ncias de focos de calor. Essa abordagem transforma um conjunto de pontos em uma superf√≠cie cont√≠nua de intensidade, evidenciando √°reas com maior ou menor densidade (nesse caso a frequencia) de eventos.

```{r echo=FALSE, fig.align="center", out.width="60%", fig.cap="Localiza√ß√£o da ocorr√™ncia de casos de dengue em Belo Horizonte/MG"}
knitr::include_graphics('figuras/dengueBH.png')
```

A t√©cnica foi aplicada para identificar √°reas de maior risco de dengue em Belo Horizonte/MG. O mapa resultante revela zonas de alta concentra√ß√£o de casos, o que pode subsidiar a√ß√µes de controle vetorial e pol√≠ticas p√∫blicas de sa√∫de mais direcionadas.

O objetivo principal √© estimar a fun√ß√£o de intensidade espacial $\hat{\lambda}_{\tau}(u)$, que descreve a probabilidade de ocorr√™ncia de eventos em diferentes locais da regi√£o de estudo.


```{r echo=F, fig.align="center", out.width= "45%", fig.show='hold'}
knitr::include_graphics('figuras/kernel2.png')
```

* Estimador de intensidade de distribui√ß√£o de pontos: 

$$\hat{\lambda}_{\tau}(u) = \dfrac{1}{\tau^2}\sum k(\dfrac{d(u_i , u)}{\tau}) \text{   ,   } d(u_i , u) \leq \tau$$

Sabendo que:

- $\hat{\lambda}_{\tau}(u)$: estimativa da intensidade do processo pontual no ponto $u$.
    
- $\tau$: par√¢metro de suaviza√ß√£o (largura de banda), define o raio de influ√™ncia dos pontos ao redor de $u$.
    
- $u_i$: coordenadas dos pontos observados no plano (ex.: localiza√ß√£o dos eventos).
    
- $d(u_i, u)$: dist√¢ncia entre o ponto observado $u_i$ e o ponto de avalia√ß√£o $u$. Normalmente, a dist√¢ncia euclidiana.
    
- $k(\cdot)$: fun√ß√£o kernel que define o peso atribu√≠do a cada ponto com base na dist√¢ncia. Exemplos:
    
i) *Kernel gaussiano*: atribui maior peso aos pontos mais pr√≥ximos.
ii) *Kernel uniforme*: todos os pontos dentro do raio recebem o mesmo peso.
iii) *Kernel Epanechnikov*: pesos decrescem com a dist√¢ncia, chegando a zero na borda.

    
- Condi√ß√£o $d(u_i, u) \leq \tau$: garante que apenas os pontos dentro da vizinhan√ßa (de raio $\tau$) contribuam para a estimativa.
    
### Como funciona:

- Para cada ponto no espa√ßo, √© aplicado um funil de suaviza√ß√£o (kernel) que distribui "peso" ao redor do ponto, atribuindo maior peso √†s √°reas pr√≥ximas e menor peso conforme a dist√¢ncia aumenta.

- Ou seja, esse peso decresce com o aumento da dist√¢ncia a partir do centro, de acordo com uma fun√ß√£o $k(\cdot)$, e √© controlado por um par√¢metro chamado largura de banda ($\tau$).

- O resultado √© uma superf√≠cie cont√≠nua de densidade, onde regi√µes com cores mais quentes (vermelho, laranja) indicam maior concentra√ß√£o de eventos.

::: box-dica1

üåßÔ∏è Analogia intuitiva:

O kernel atua como um limpador de para-brisa, pesando mais os eventos pr√≥ximos e menos os eventos muito distantes. A escolha do tamanho do limpador ($\tau$) e do tipo de movimento (forma da fun√ß√£o kernel) define o quanto voc√™ v√™ ao redor do ponto onde est√° focando.
:::

```{r echo=F, fig.align="center", out.width= "50%", fig.show='hold'}
knitr::include_graphics('figuras/kernel3.png')
```

A figura acima mostra como diferentes larguras de banda ($500 m$, $1.500 m$ e $2.500 m$) alteram o grau de suaviza√ß√£o:

i) Largura pequena ($500 m$): permite detectar agrupamentos muito locais, mas pode introduzir ru√≠dos, ou seja, varia√ß√µes artificiais causadas por flutua√ß√µes aleat√≥rias nos dados, que n√£o representam padr√µes reais.

ii) Largura intermedi√°ria ($1.500 m$): equil√≠brio entre detalhe e suavidade.

Largura maior ($2.500 m$): suaviza padr√µes locais, ideal para visualizar tend√™ncias gerais.


[*Fonte: Refer√™ncia cient√≠fica: Druck, S.; Carvalho, M.S.; C√¢mara, G.; Monteiro, A.V.M. (eds) "An√°lise Espacial de Dados Geogr√°ficos". Bras√≠lia, EMBRAPA, 2004](http://www.dpi.inpe.br/gilberto/livro/analise/cap2-eventos.pdf)


# Geoestat√≠stica

* Dados usados em geoestat√≠stica s√£o atributos cont√≠nuos medidos em localiza√ß√µes fixas, na maioria das vezes amostrados no espa√ßo geogr√°fico, e que queremos analisar para entender como um fen√¥meno varia no espa√ßo.

## Estrutura dos dados geoestat√≠sticos

Imagine que voc√™ tem um conjunto de pontos no mapa, e para cada ponto voc√™ tem um valor observado. O conjunto de dados geralmente tem:

|   Latitude   |  Longitude   | Atributo Mensurado |
|:-----------:|:------------:|:----------------:|
|   -22.90    |   -43.20     |       5.4        |
|   -22.91    |   -43.22     |       6.1        |
|   -22.92    |   -43.18     |       5.9        |

## Exemplos de aplica√ß√£o

::: box-dica3
- üåßÔ∏è Medi√ß√£o da quantidade de chuva em diferentes locais de uma cidade.</li>
- ü¶ü Contagem de ovos de Aedes aegypti em ovitrampas.</li>
- üå´Ô∏è Concentra√ß√£o de poluentes no ar em pontos georreferenciados.</li>
- üåΩ An√°lise da produtividade agr√≠cola em diferentes talh√µes de uma fazenda.</li>

:::


* Umas das aplica√ß√µes mais importantes da geoestat√≠stica √© a interpola√ß√£o de dados, ou seja, estima√ß√£o de valores em locais onde n√£o h√° medi√ß√£o.


## Semivariograma: a base da an√°lise espacial

Uma das principais ferramentas da geoestat√≠stica √© o semivariograma, que mede o quanto dois pontos pr√≥ximos no espa√ßo se parecem (ou se diferem) com rela√ß√£o ao valor de uma vari√°vel.

::: box-dica2
**A ideia central √©**: Se dois pontos est√£o muito pr√≥ximos, √© esperado que seus valores sejam parecidos. J√° se estiverem distantes, a diferen√ßa entre os valores tende a aumentar.

:::

A vers√£o experimental do semivariograma √© calculada para diferentes dist√¢ncias entre os pontos, usando a seguinte f√≥rmula:

<!-- * A determina√ß√£o experimental do semivariograma, para cada valor de $x_i$, considera todos os pares de amostras $z(x)$ e $z(x+h)$, separadas pelo vetor dist√¢ncia $h$, a partir da equa√ß√£o:  -->

<!-- ```{r echo=F, fig.align="center", out.width= "25%", fig.show='hold'} -->
<!-- knitr::include_graphics('figuras/variograma3.png') -->
<!-- ``` -->


$$\hat{\gamma}(h) = \dfrac{1}{2N(h)}\sum^{N(h)}_{i=1}[z(x_i) - z(x_i + h)]^2 $$
 Sabendo que:
 
 - $\hat{\gamma}(h)$: valor estimado do fen√¥meno para a dist√¢ncia $h$;

- $N(h)$: n√∫mero de pares de pontos separados por uma dist√¢ncia $h$;

- $z(x_i)$: valor observado da vari√°vel na localiza√ß√£o $x_i$;

- $z(x_i + h)$: valor observado da vari√°vel em um ponto a uma dist√¢ncia $h$ de $x_i$.

* A express√£o representa a \textbf{diferen√ßa m√©dia ao quadrado} entre os valores da vari√°vel observada em pares de pontos separados pela dist√¢ncia $h$.



<!-- * Sendo $\hat{\gamma}(h)$ o semivariograma estimado e $N(h)$ o n√∫mero de pares de valores medidos, $z(x)$ e $z(x+h)$, separados pelo vetor $h$.   -->

```{r echo=F, fig.align="center", out.width= "40%", fig.show='hold'}
include_graphics('figuras/variograma1.png')
```

::: box-dica1

üìå **Efeito Pepita (C‚ÇÄ)**: √â a varia√ß√£o observada mesmo quando a dist√¢ncia entre os pontos √© muito pequena ou zero. Costuma representar erros de medi√ß√£o ou variabilidade microsc√≥pica n√£o capturada.

üìå **Patamar (C)**: √â o valor em que o variograma se estabiliza, indicando que a partir de certa dist√¢ncia, a variabilidade entre os pontos n√£o aumenta mais. Representa a vari√¢ncia total dos dados.

üìå **Alcance (a)**: √â a dist√¢ncia a partir da qual dois pontos deixam de estar correlacionados. At√© essa dist√¢ncia, os valores ainda apresentam semelhan√ßa espacial, ou seja, ap√≥s essa dist√¢ncia, tornam-se independentes.

:::

Apesar de √∫til, essa f√≥rmula n√£o √© robusta em todas as situa√ß√µes. Em alguns casos, a variabilidade n√£o √© constante ao longo da √°rea estudada ‚Äî o que chamamos de heterocedasticidade. Nesses cen√°rios, modelos diferentes podem ser utilizados para representar o comportamento do semivariograma. Por exemplo:

- Modelo Exponencial

- Modelo Esf√©rico

- Modelo Gaussiano




```{r echo=F, fig.align="center", out.width= "40%", fig.show='hold'}
include_graphics('figuras/variograma2.png')
```


* **Exemplo:** Mapa sobre o teor de argila no solo.

```{r echo=F, fig.align="center", out.width= "70%", fig.show='hold'}
knitr::include_graphics('figuras/geoestatistica7.png')
```

A imagem mostra a interpola√ß√£o do teor de argila em uma √°rea agr√≠cola da Fazenda Canchim (SP), a partir de amostras de solo coletadas em campo. Diversos m√©todos s√£o comparados: **a geoestat√≠stica (krigagem)**, que utiliza a estrutura de depend√™ncia espacial dos dados via semivariograma e produz um mapa suavizado e estatisticamente robusto; o m√©todo do **inverso da dist√¢ncia (IDW)**, que pondera os pontos mais pr√≥ximos com maior influ√™ncia, resultando em maior detalhamento local, mas com risco de exagerar varia√ß√µes; a **m√©dia simples**, que suaviza os dados sem considerar plenamente a variabilidade espacial; e o m√©todo do **vizinho mais pr√≥ximo**, que gera √°reas abruptas ao atribuir a cada regi√£o o valor da amostra mais pr√≥xima, sem suaviza√ß√£o. O exemplo evidencia como a escolha do m√©todo de interpola√ß√£o impacta diretamente a qualidade e continuidade do mapa final.



[*Fonte: Refer√™ncia cient√≠fica: Druck, S.; Carvalho, M.S.; C√¢mara, G.; Monteiro, A.V.M. (eds) "An√°lise Espacial de Dados Geogr√°ficos". Bras√≠lia, EMBRAPA, 2004](http://www.dpi.inpe.br/gilberto/livro/analise/cap3-superficies.pdf)

# Dados de √Årea

* Na an√°lise espacial por √°reas, o atributo de interesse costuma ser uma medida agregada (como contagem de casos, taxa de mortalidade, m√©dia de renda, etc.) calculada dentro de uma unidade geogr√°fica bem definidas (como bairros, munic√≠pios, setores censit√°rios ou regi√µes administrativas.)

* Essas √°reas s√£o representadas por pol√≠gonos, que podem ter formas irregulares e manter rela√ß√µes espaciais com as √°reas vizinhas, seja por fronteiras compartilhadas, conex√µes f√≠sicas (como estradas e rios), ou por semelhan√ßas em caracter√≠sticas socioecon√¥micas (como n√≠vel de renda ou acesso a servi√ßos).

::: box-dica2
O objetivo da an√°lise de dados de √°rea √© identificar, explicar e interpretar padr√µes espaciais e tend√™ncias que ocorrem entre essas unidades geogr√°ficas pr√©-definidas.

:::

## Exemplos de aplica√ß√£o

::: box-dica3

- ü¶ü Taxa de incid√™ncia de dengue por bairro em uma cidade.
- üí∏ Renda per capita por setor censit√°rio.
- üåΩ Produtividade agr√≠cola por microrregi√£o.
- üè´ Taxa de evas√£o escolar por munic√≠pio.
- üöî Taxa de criminalidade por distrito policial.
- üì¶ Volume de vendas por zona de entrega.
:::

## Mapa Tem√°tico

* O mapa tem√°tico tem como principal objetivo visualizar e analisar a distribui√ß√£o espacial de um fen√¥meno espec√≠fico.

* O mapa tem√°tico abaixo mostra a frequ√™ncia de artigos cient√≠ficos selecionados na revis√£o integrativa sobre diagn√≥stico microbiol√≥gico de Salmonella spp. na aquicultura entre 2000 e 2020 por pa√≠ses de diferentes continentes. Fonte: Porto et al. 2023 ([link](https://tede.ufrrj.br/jspui/bitstream/jspui/6673/2/2023%20-%20Yuri%20Duarte%20Porto%20%28parcialmente%20liberada%29.pdf)).

```{r echo=F, fig.align="center", out.width="70%"}
knitr::include_graphics('figuras/tese_yuri.png')
```


## Matriz de Vizinhan√ßa

- A **matriz de vizinhan√ßa** \( W \) √© uma matriz quadrada de dimens√£o \( n \times n \), onde cada elemento \( w_{ij} \) representa uma **medida de proximidade ou conectividade espacial** entre duas regi√µes \( O_i \) e \( O_j \).

- Essa matriz √© fundamental na an√°lise espacial, pois define **quais √°reas s√£o consideradas vizinhas** e como essa vizinhan√ßa influencia os fen√¥menos observados.

```{r echo=F, fig.align="center", out.width="80%"}
knitr::include_graphics('figuras/vizinhanca.png')
```

- A matriz \( W \) pode ser **bin√°ria** (0 ou 1) ou **ponderada**, dependendo do crit√©rio adotado.

::: box-dica4

üìå Crit√©rios comuns para definir vizinhan√ßa:

- \( w_{ij} = 1 \), se \( O_i \) **toca** \( O_j \) (ou seja, compartilham uma fronteira comum). Esse tamb√©m √© chamado de crit√©rio de **contiguidade**.

- \( w_{ij} = 1 \), se a **dist√¢ncia entre os centr√≥ides** das regi√µes \( O_i \) e \( O_j \) for **menor que um limite \( h \)**. Esse √© o crit√©rio baseado em **dist√¢ncia geogr√°fica**.

- \( w_{ij} = \frac{l_{ij}}{l_i} \), onde:

  - \( l_{ij} \): comprimento da fronteira compartilhada entre \( O_i \) e \( O_j \)
  
  - \( l_i \): per√≠metro total da regi√£o \( O_i \) 
  
  Esse crit√©rio expressa a **propor√ß√£o da fronteira** de \( O_i \) que est√° em contato com \( O_j \), e √© √∫til para an√°lises mais refinadas de conectividade.

:::



## Moran Global, Moran Local e Lisa Map

### üßÆ Moran Global

* Mede a autocorrela√ß√£o espacial global, ou seja, se valores semelhantes est√£o agrupados no espa√ßo.


$$I = \frac{ \sum_{i=1}^{n} \sum_{j=1}^{n} w_{ij} (y_i - \bar{y})(y_j - \bar{y}) }{ \sum_{i=1}^{n} (y_i - \bar{y})^2 }$$

::: box-dica4

* $I > 0$: valores similares est√£o pr√≥ximos (agrupamento positivo).

* $I < 0$: valores diferentes est√£o pr√≥ximos (dispers√£o).

* $I \approx 0$: padr√£o aleat√≥rio.

:::

Sabendo que:

- \( I \): valor do √≠ndice de Moran global.
- \( n \): n√∫mero total de unidades espaciais (regi√µes).
- \( y_i \): valor da vari√°vel de interesse na regi√£o \( i \).
- \( \bar{y} \): m√©dia dos valores de \( y \) em todas as regi√µes.
- \( w_{ij} \): elemento da matriz de vizinhan√ßa que representa a rela√ß√£o espacial entre as regi√µes \( i \) e \( j \).
  - \( w_{ij} = 1 \) se \( i \) e \( j \) s√£o vizinhos, 0 caso contr√°rio (ou ponderado).
- O numerador mede a covari√¢ncia espacial ponderada, e o denominador √© a vari√¢ncia total de \( y \).

### üßÆ Moran Local (LISA)

* Avalia a autocorrela√ß√£o espacial **local**, permitindo identificar regi√µes com agrupamentos (clusters) ou comportamentos at√≠picos.

$$I^{(i)} = \frac{n}{\sum_{j=1}^{n} (z_j - \bar{z})^2} \sum_{j=1}^{n} w_{ij} (z_i - \bar{z})(z_j - \bar{z})$$

Sabendo que:

- \( I^{(i)} \): √≠ndice de Moran local para a regi√£o \( i \).
- \( n \): n√∫mero total de regi√µes.
- \( z_i \): valor padronizado (ou original, dependendo da conven√ß√£o) da vari√°vel na regi√£o \( i \).
- \( \bar{z} \): m√©dia da vari√°vel \( z \).
- \( w_{ij} \): peso espacial entre as regi√µes \( i \) e \( j \).
- A soma considera a influ√™ncia dos vizinhos \( j \) sobre o ponto \( i \), ponderada pela matriz de vizinhan√ßa.

::: box-dica2

üó∫Ô∏è Resumindo

- **Moran Global** indica se h√° padr√£o geral de autocorrela√ß√£o espacial (positivo, negativo ou aleat√≥rio).

- **Moran Local** revela **onde** esses padr√µes ocorrem: clusters de alto/alto (*hotspots*), baixo/baixo (*coldspots*), alto/baixo (*outliers*), etc.

:::
<!-- ```{r echo=F, fig.align="center", out.width="20%", fig.cap="Moran Global"} -->
<!-- knitr::include_graphics('figuras/moran_global.png') -->
<!-- ``` -->

<!-- ```{r echo=F, fig.align="center", out.width="30%", fig.cap="Moran Local"} -->
<!-- knitr::include_graphics('figuras/moran_local.png') -->
<!-- ``` -->


### üó∫Ô∏è LISA Map

O LISA Map √© um mapa tem√°tico que representa graficamente os resultados do √çndice de Moran Local. Ele identifica:

- Clustering local (agrupamento de valores semelhantes)

- Outliers espaciais (valores discrepantes em rela√ß√£o aos vizinhos)

- Regi√µes n√£o significativas (sem padr√£o espacial detect√°vel)


| Tipo de Associa√ß√£o        | Descri√ß√£o                                                | Interpreta√ß√£o Espacial                                                |
| ------------------------- | -------------------------------------------------------- | --------------------------------------------------------------------- |
| üî¥ **Alto-Alto (High-High)** | Valor alto cercado por vizinhos tamb√©m com valores altos | Indica **cluster de altas magnitudes**, tamb√©m chamado de **hotspot** |
| üîµ **Baixo-Baixo (Low-Low)** | Valor baixo cercado por vizinhos com valores baixos      | Indica **cluster de baixas magnitudes**, ou **coldspot**              |
| üü† **Alto-Baixo (High-Low)** | Valor alto cercado por valores baixos                    | Indica um **outlier espacial positivo**                               |
| üü° **Baixo-Alto (Low-High)** | Valor baixo cercado por valores altos                    | Indica um **outlier espacial negativo**                               |
| ‚ö™ **N√£o significativo**     | Sem associa√ß√£o espacial relevante                        | O valor na regi√£o n√£o apresenta padr√£o espacial detect√°vel            |


Os valores do Moran Local s√£o testados por permuta√ß√£o para verificar se o padr√£o observado √© estatisticamente significativo ou poderia ocorrer por acaso.

Apenas as regi√µes significativas (p-valor < 0.05) costumam ser coloridas nos mapas.

<!-- * Desigualdade no n√≠vel distrital na cobertura de sa√∫de reprodutiva, materna, neonatal e infantil na √çndia -->

<!-- ```{r echo=F, fig.align="center", out.width="90%"} -->
<!-- knitr::include_graphics('figuras/moran_local2.png') -->
<!-- ``` -->

<!-- [Fonte: PANDA, Basant Kumar; KUMAR, Gulshan; AWASTHI, Ashish. District level inequality in reproductive, maternal, neonatal and child health coverage in India. BMC public health, v. 20, n. 1, p. 1-10, 2020.](https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-020-8151-9) -->

Esse mapa abaixo pertence ao artigo ["Are regions equal in adversity? A spatial analysis of the spread and dynamics of COVID-19 in Europe", de Amdaoud, Arcuri e Levratto (2021)](https://www.researchgate.net/publication/349729379_Are_regions_equal_in_adversity_A_spatial_analysis_of_the_spread_and_dynamics_of_COVID-19_in_Europe). O artigo realiza uma an√°lise espacial detalhada da mortalidade por COVID-19 em 125 regi√µes europeias durante a primeira onda da pandemia (mar√ßo a maio de 2020). 

```{r echo=F, fig.align="center", out.width="80%"}
knitr::include_graphics('figuras/lisa_map_covid.png')
```

Utilizando o √≠ndice de Moran Local (LISA), o estudo identifica padr√µes de autocorrela√ß√£o espacial na mortalidade por COVID-19 entre as regi√µes europeias durante a primeira onda da pandemia. O resultado evidencia clusters espaciais significativos, com destaque para regi√µes High-High (altas taxas de mortalidade cercadas por outras com altas taxas), como o norte da It√°lia, Madrid e a regi√£o da Als√°cia, na Fran√ßa. Ao mesmo tempo, regi√µes Low-Low, como o sul da It√°lia, Dinamarca e partes da Alemanha Oriental, apresentaram baixa mortalidade em vizinhan√ßa igualmente baixa. Esses padr√µes persistentes ao longo do tempo indicam que a dissemina√ß√£o da pandemia seguiu l√≥gicas regionais, refor√ßando a import√¢ncia de pol√≠ticas p√∫blicas que considerem as desigualdades territoriais na resposta √† crise sanit√°ria.

## Modelos de Regress√£o Espacial

* `r colFmt(" Hip√≥tese de independ√™ncia das observa√ß√µes em geral √© Falsa ",'orange')` $\rightarrow$  Existe depend√™ncia espacial, ou seja, o valor observado em uma localiza√ß√£o tende a se parecer com os valores observados em locais vizinhos.

* Efeitos Espaciais $\rightarrow$ Se existir depend√™ncia ou correla√ß√£o espacial significativa, devemos incluir no modelo os `r colFmt(" Efeitos Espaciais ",'darkpurple')`, caso contr√°rio, as estimativas geradas pelo modelo de regress√£o podem ficar enviesadas, criando associa√ß√µes esp√∫rias (isto √©, sugerindo rela√ß√µes estat√≠sticas onde elas n√£o existem de fato, ou mascarando rela√ß√µes reais);

* `r colFmt("**Como verificar ?** ",'darkred')` $\rightarrow$ Para detectar a depend√™ncia espacial, podemos analisar os res√≠duos da regress√£o tradicional (OLS), utilizando indicadores como o √≠ndice de Moran dos res√≠duos. Se os res√≠duos mostrarem autocorrela√ß√£o espacial significativa, isso indica que h√° estrutura espacial n√£o modelada.

* `r colFmt("**Detectada a autocorrela√ß√£o espacial: e agora ?** ",'darkblue')` $\rightarrow$  √â necess√°rio adotar modelos de regress√£o que incorporem explicitamente os efeitos espaciais, evitando vieses nas estimativas dos coeficientes.


### i) Modelos Globais: 

* Esses modelos assumem que a estrutura espacial √© constante em todo o espa√ßo geogr√°fico. Utilizam um √∫nico par√¢metro para captar a autocorrela√ß√£o.

* Um exemplo √© o **Modelo de Erro Espacial** (*Spatial Error Model* - **CAR**), representado por:
    
$$y_i = \beta_0 + \sum^{p}_{k} \beta_k x_{ik}  + \varepsilon_i \text{    , sendo  }  \varepsilon_i = \lambda  W + \xi$$

::: box-dica4
Sendo:

- $y_i$: valor observado da vari√°vel dependente na unidade $i$;

- $\beta_0$: intercepto da regress√£o;

- $\beta_k$: coeficiente da $k$-√©sima vari√°vel explicativa;

- $x_{ik}$: valor da $k$-√©sima vari√°vel explicativa para a unidade $i$;

- $\varepsilon_i$: erro com estrutura de autocorrela√ß√£o espacial;


- $\lambda$: coeficiente de autocorrela√ß√£o espacial;

- $W$: matriz de vizinhan√ßa espacial (define como cada unidade est√° conectada √†s outras);

- $\xi$: erro aleat√≥rio normal (sem autocorrela√ß√£o), com $\mathbb{E}[\xi]()
:::

$\rightarrow$ Podemos observar que os efeitos da autocorrela√ß√£o espacial s√£o associados ao termo de erro.

::: box-dica2

üß† Interpreta√ß√£o:

- Se $\lambda \ne 0$, h√° evid√™ncia de depend√™ncia espacial nos erros, ou seja, o erro em uma localidade est√° correlacionado com os erros em localidades vizinhas.

- Se $\lambda = 0$, o modelo reduz-se a uma regress√£o tradicional, e n√£o h√° autocorrela√ß√£o espacial significativa.
:::



### ii) Modelos Locais: 

* Enquanto os modelos globais assumem uma rela√ß√£o espacial uniforme, os modelos locais admitem que os par√¢metros da regress√£o variam ao longo do espa√ßo geogr√°fico.

* Um exemplo cl√°ssico √© o Modelo **Geograficamente Ponderado** (*Geographically Weighted Regression* - **GWR**), expresso por:
  
    
<!-- $$y_i = \beta_{0}(u_i, v_i) + \sum^{p}_{k}  \beta_k (u_i, v_i) x_{ik} + \varepsilon_i \text{    , sendo  } (u_i, v_i) \text{    as coordenadas geogr√°ficas}$$ -->

<!-- Onde: -->

<!-- - $(u_i, v_i)$ representam as \textbf{coordenadas geogr√°ficas} da observa√ß√£o $i$; -->
<!-- - Os coeficientes $\beta_k(u_i, v_i)$ s√£o estimados \textbf{localmente}, variando de acordo com a posi√ß√£o no espa√ßo. -->


\[
y_i = \beta_{0}(u_i, v_i) + \sum_{k=1}^{p} \beta_k(u_i, v_i) \cdot x_{ik} + \varepsilon_i,
\\
\quad \text{com } \beta_k(u_i, v_i) \text{ estimado via } 
\sum_{j=1}^{n} K(d_{ij}) \cdot x_{jk}
\]

::: box-dica4

Onde:

- $(u_i, v_i)$: coordenadas geogr√°ficas da observa√ß√£o $i$;

- $\beta_k(u_i, v_i)$: coeficiente local da vari√°vel explicativa $x_k$, estimado para a posi√ß√£o $i$;

- $K(d_{ij})$: fun√ß√£o kernel que atribui um peso √† observa√ß√£o $j$ com base na dist√¢ncia $d_{ij}$ entre as localiza√ß√µes $i$ e $j$;
:::

$\rightarrow$ Quanto menor $d_{ij}$, maior √© o peso de $j$ na estima√ß√£o de $\beta_k(u_i, v_i)$.
  
[Fonte: ARDILLY, Pascal et al. Manuel d‚Äôanalyse spatiale. 2018.](https://ec.europa.eu/eurostat/documents/3859598/9462709/INSEE-ESTAT-SPATIAL-ANA-18-EN.pdf)

<!-- ## Como trabalhar com An√°lise Estat√≠stica Espacial: Algumas ferramentas -->

<!-- ### SiG QGIS -->

<!-- ```{r echo=F, fig.align="center", out.width="80%"} -->
<!-- knitr::include_graphics('figuras/QGIS.png') -->
<!-- ``` -->

<!-- [QGIS: Um Sistema de Informa√ß√£o Geogr√°fica livre e aberto](https://www.qgis.org/pt_BR/site/) -->

<!-- ### GEODA -->

<!-- ```{r echo=F, fig.align="center", out.width="80%"} -->
<!-- knitr::include_graphics('figuras/GEODA.png') -->
<!-- ``` -->

<!-- [GEODA: AN INTRODUCTION TO SPATIAL DATA ANALYSIS](https://spatial.uchicago.edu/geoda) -->


<!-- ### R -->

<!-- ```{r echo=F, fig.align="center", out.width="60%"} -->
<!-- knitr::include_graphics('figuras/logo_ubuntu.png') -->
<!-- ``` -->

<!-- Fonte: [Dicas para integra√ß√£o e instala√ß√£o do R 4.2 no Ubuntu 22.04 LTS e os pacotes espaciais](https://rtask.thinkr.fr/installation-of-r-4-2-on-ubuntu-22-04-lts-and-tips-for-spatial-packages/) -->


<!-- ### Python -->

<!-- ```{r echo=F, fig.align="center", out.width="60%"} -->
<!-- knitr::include_graphics('figuras/geopandas.png') -->
<!-- ``` -->

<!-- Fonte: [Github Geopandas](https://geopandas.org/en/stable/) -->

<!-- # Ser√£o feitas cinco aplica√ß√µes da Estat√≠stica Espacial utiliza√ß√£o o pacote estat√≠stico R: -->

<!-- [Clique aqui para baixar os dados das aplica√ß√µes](https://drive.google.com/drive/folders/10WMJYlwHcEX9zw3_RUjDQz5DGZByiI2N?usp=sharing) -->

# **Aplica√ß√£o I:** Utilizando a biblioteca *tmap* para constru√ß√£o r√°pida de mapas tem√°ticos

```{r, echo=T, out.width='90%'}
library(tmap)

# Carrega dados espaciais do mundo com vari√°veis socioecon√¥micas
data(World)

# Define o estilo do mapa (opcional, apenas visual)
tmap_style("classic")

# Cria um mapa tem√°tico utilizando a vari√°vel esperan√ßa de vida
qtm(World, fill = "life_exp", 
    title = "Esperan√ßa de Vida por Pa√≠s",
    fill.title = "Anos",
    borders = "gray40")

```

<!-- ## Exerc√≠cio proposto: -->

<!-- Altere o script para representar outra vari√°vel (por exemplo, taxa de alfabetiza√ß√£o, popula√ß√£o, ou √°rea). O que muda na interpreta√ß√£o do mapa ? Quais pa√≠ses se destacam em cada caso ? -->


# **Aplica√ß√£o II:** Baixando e construindo mapas a partir da biblioteca *geobr*

### Bibliotecas que ser√£o utilizadas:

```{r, echo=T}
library(ggplot2)
library(dplyr)
library(viridis)
library(geobr)
library(sf)
library(maptools)
library(leaflet)
library(ggspatial)

```

Para acessar os dados dos limites territoriais de todos os estados brasileiros √© necess√°rio utilizar a fun√ß√£o *read_state*.

```{r, echo=T}
brasil.ufs <- read_state(code_state = "all", year=2019, showProgress = FALSE)
```

### Primeiro, vamos fazer um gr√°fico apenas com as geometrias.

```{r, echo=T}
ggplot(brasil.ufs) + 
  geom_sf()
```

Para a constru√ß√£o de um mapa onde cada estado recebe uma cor de acordo com a sua regi√£o geogr√°tica, procedemos da seguinte forma: 
  
```{r, echo=T,  out.width="90%"}
ggplot(brasil.ufs) + 
  geom_sf(aes(fill = name_region)) + 
  labs(fill="Regi√£o")
```

Para plotar o mapa, agora utilizaremos dados relativos ao acesso √† rede de esgoto de acordo com a unidade da federa√ß√£o ([fonte dos dados](https://pt.wikipedia.org/wiki/Lista_de_unidades_federativas_do_Brasil_por_acesso_%C3%A0_rede_de_esgoto) ) segundo o censo de 2022. Vamos associar esses dados a tabela de acordo com a vari√°vel State e padronizaremos a porcentagem para variar de 0 a 100.


```{r, echo=T,  out.width="90%"}
# Entrando com os dados observados na wikipedia
acesso_esgoto <- data.frame(
  sigla = c("SP", "DF", "RJ", "MG", "ES",
            "PR", "RS", "PE", "GO", "SC",
            "BA", "MS", "RR", "CE", "SE",
            "PB", "AC", "AM", "AL", "TO",
            "MT", "RN", "PI", "PA", "RO",
            "AP", "MA"),
  
  rede_esgoto = c(93.6, 89.9, 88.9, 81.4, 78.2,
                  73.7, 71.0, 65.1, 61.7, 61.4,
                  59.5, 57.2, 56.0, 52.8, 51.0,
                  49.9, 47.7, 47.0, 40.6, 39.8,
                  37.4, 35.8, 26.8, 23.5, 21.7,
                  20.7, 18.1)
)

```



```{r, echo=T,  out.width="90%"}
# Unindo os dados com o shapefile

brasil.ufs <- brasil.ufs %>%
  left_join(acesso_esgoto, by = c("abbrev_state" = "sigla"))


```

<center>

  
```{r, echo=T,  out.width="90%"}
# Construindo o mapa com ggplot
brasil.ufs |>
  ggplot(aes(fill = rede_esgoto), color = "black") + 
  geom_sf() + 
  scale_fill_viridis(name = "Munic√≠pios com rede de esgoto (%)", direction = -1) + 
  xlab("Longitude") + ylab("Latitude") + annotation_scale(location = "bl") +
  annotation_north_arrow(location = "br") + 
  theme_minimal()
```

</center>
  
Uma forma alteranativa de apresentar esses mesmos dados se d√° pela apresenta√ß√£o de c√≠rculos com raios proporcionais a porcentgem de munic√≠pios com rede de esgoto no centroide de cada geometria (nesse caso, UF).

```{r, echo=T,  out.width="80%"}
# Calcula o centroide de cada estado no objeto espacial brasil.ufs.
coord_pontos <- brasil.ufs |>  
  st_centroid()
```

<center>

 
```{r, echo=T,  out.width="90%"}
# Construindo o mapa com ggplot
ggplot(brasil.ufs) + 
  geom_sf() + 
  geom_sf(data = coord_pontos, aes(size = rede_esgoto), col = "blue", 
          alpha = .65, show.legend = "point") +
    scale_size_continuous(name = "Munic√≠pios com rede de esgoto (%)") + 
    xlab("Longitude") + 
    ylab("Latitude") +
    annotation_scale(location = "bl") +
    annotation_north_arrow(location = "br") +
  theme_minimal()
```


</center>


Uma alternativa interativa para trabalhar com mapas √© com a utiliza√ß√£o do pacote *leaflet*
  
<center>

```{r, echo=T,  out.width="70%"}
leaflet(coord_pontos) |>
  # Camada tradicional com nomes e divis√µes pol√≠ticas
  addProviderTiles(providers$OpenStreetMap, group = "Mapa Pol√≠tico") |>
  # Camada de imagem de sat√©lite
  addProviderTiles(providers$Esri.WorldImagery, group = "Sat√©lite") |>
  # Adiciona os c√≠rculos nos centroides
  addCircleMarkers(
    label = ~ paste0(abbrev_state, ": ", rede_esgoto, "%"), # R√≥tulo exibido ao passar o mouse
    labelOptions = labelOptions(textsize = "13px"), # Tamanho da fonte do r√≥tulo
    radius = ~ rede_esgoto / 10,              # Raio do c√≠rculo proporcional
    fillOpacity = 0.5,                       # Transpar√™ncia dos c√≠rculos
    group = "Dados"
  ) |>
  # Adiciona controle para alternar entre as camadas de fundo
  addLayersControl(
    baseGroups = c("Mapa Pol√≠tico", "Sat√©lite"),
    overlayGroups = "Dados",
    options = layersControlOptions(collapsed = FALSE)
  )

```  
  
</center>
  
---

# **Aplica√ß√£o III:** Dengue em Dourados/MS - Parte 1: An√°lise explorat√≥ria

* Nesta apresenta√ß√£o, ser√£o utilizados dados com ru√≠do espacial, com o objetivo de preservar a confidencialidade das informa√ß√µes originais. Esses dados fazem parte da disserta√ß√£o de [Isis Rodrigues Reitman](https://sucupira.capes.gov.br/sucupira/public/consultas/coleta/trabalhoConclusao/viewTrabalhoConclusao.jsf?popup=true&id_trabalho=3666174), intitulada *‚ÄúSa√∫de e Ambiente Urbano: a rela√ß√£o de incid√™ncia de dengue e as disparidades espaciais em Dourados ‚Äì MS‚Äù*, apresentada em abril de 2016 no [Programa de P√≥s-Gradua√ß√£o em Geografia da Universidade Federal da Grande Dourados (UFGD)](https://portal.ufgd.edu.br/pos-graduacao/mestrado-doutorado-geografia/index).

* Os ru√≠dos nas coordenadas foram gerados a partir de uma distribui√ß√£o uniforme. A fun√ß√£o produz valores aleat√≥rios entre -15 e 15 para cada linha do conjunto de dados. Esse procedimento simula um deslocamento m√°ximo de at√© 15 metros em cada dire√ß√£o, o que √© suficiente para preservar o padr√£o espacial geral dos casos, ao mesmo tempo em que evita a identifica√ß√£o precisa das localiza√ß√µes originais.

```{r, eval=FALSE, echo = TRUE}
# Supondo que seu dataframe se chame `casos`
# Adicionando um ru√≠do aleat√≥rio pequeno (por exemplo, at√© ¬±15 metros) √†s coordenadas X e Y

set.seed(123)  # Para reprodutibilidade
casos$X_ruido <- casos$X + runif(nrow(casos), -15, 15)
casos$Y_ruido <- casos$Y + runif(nrow(casos), -15, 15)
```


* Essa aplica√ß√£o tamb√©m se encontra no [Curso de Estudos Ecol√≥gicos](https://ogcruz.github.io/) ministrado para o curso de [P√≥s-Gradua√ß√£o em Epidemiologia em Sa√∫de P√∫blica](http://ensino.ensp.fiocruz.br/cursos/mestrado-e-doutorado/epidemiologia-em-saude-publica) em 2019, pelos pesquisadores [Oswaldo Gon√ßalves Cruz (PROCC/FIOCRUZ)](https://lsbastos.github.io/PROCC/membro-9530671289607786.html) e [Wagner Tassinari (DEMAT/ICE/UFRRJ)](https://institucional.ufrrj.br/ruralpesquisa/wagner-de-souza-tassinari/)

 **OBS:** Os dados e as malhas geogr√°ficas utilizadas nessa apresenta√ß√£o, est√£o dispon√≠veis no seguinte endere√ßo: ([link](https://github.com/wtassinari/Estatistica_Espacial/tree/main/dados))


### Biliotecas do R que ser√£o utilizadas

```{r, echo=T}

library(readr)
library(tidyverse)
library(sf)
library(maptools)
library(spatstat)
library(tmap)
```

#### Lendo a tabela da popula√ß√£o por setor censit√°rio e os *shapes files* do contorno e por setor censit√°rio de Dourados/MS

```{r, echo=T}

pop2010 <- read_csv('dados/dengue_dourados/pop2010.csv')
setor.sf <- read_sf('dados/dengue_dourados/Setor_UTM_SIRGAS.shp', crs = 31981)
contorno.sf <- read_sf('dados/dengue_dourados/contorno.shp', crs = 31981)

```

üìå O que √© CRS (Coordinate Reference System) ?

O CRS √© como uma ‚Äúregra de tradu√ß√£o‚Äù entre o que est√° em um mapa e o mundo real. Ele define como as coordenadas (como 140, 12) se relacionam com locais verdadeiros na Terra, dizendo se os valores est√£o em metros, graus ou outra unidade, e onde fica o ponto de partida (a origem). Sem um CRS, uma coordenada n√£o tem significado, pois n√£o sabemos onde ela realmente est√° nem em que escala.

üó∫Ô∏è Por que isso √© importante ?

Se dois mapas tiverem CRSs diferentes, os pontos n√£o v√£o se alinhar corretamente ‚Äî como tentar juntar pe√ßas de quebra-cabe√ßa de caixas diferentes. Usar o CRS certo garante que todas as informa√ß√µes espaciais estejam bem posicionadas e coerentes. Por exemplo, o WGS 84 √© usado por GPS e Google Maps (em graus), enquanto o UTM √© usado para mapas locais mais precisos (em metros). Saber isso evita erros em an√°lises espaciais e garante que os dados ‚Äúconversem‚Äù entre si.

**OBS:** Se quiser saber um pouco mais a respeito do CRS, basta acessar ([link](https://rspatial.org/raster/spatial/6-crs.html))


### Fazendo um join com as tabelas com os setores censit√°rios + popula√ß√£o

```{r, echo=T}
setor.sf <- setor.sf |> mutate (idsetor = as.numeric(CD_GEOCODI)) |> inner_join(pop2010, by='idsetor')
```

### Lendo e plotando os casos de dengue georreferenciados em Dourados/MS

```{r, echo=T}
casos <- read_csv('dados/dengue_dourados/dengue_dourados.csv')
casos.sf <- st_as_sf(casos, coords = c("X", "Y"), crs = 31981) 
```

```{r, echo=T, out.width="60%"}
ggplot(setor.sf) + 
  geom_sf(fill = 'white', color='black') +
  geom_sf(data=casos.sf, color='red',size=1) +
  theme_void()
```

### Lendo e plotando os os pontos de coleta de lixo georreferenciados em Dourados/MS

```{r, echo=T}
lixo <- read_csv2('dados/dengue_dourados/lixo_dourados.csv')
lixo.sf <- st_as_sf(lixo, coords = c("X", "Y"), crs = 31981)
```

```{r, echo=T,  out.width="70%"}
ggplot(setor.sf) + 
  geom_sf(fill = 'white', color = 'black') +
  geom_sf(data=lixo.sf,color='blue',size=1) +
  theme_void()
```

* Como podemos observar, existem alguns pontos de coleta de lixo fora do contorno de Dourados/MS

### Uma forma de ficarmos s√≥ com os pontos dentro do pol√≠gono √© utilizando o comando `st_intersection`.


```{r, echo=T}
lixo2.sf <- st_intersection(contorno.sf, lixo.sf)
```

```{r, echo=T,  out.width="70%"}
ggplot(setor.sf) + 
  geom_sf(fill = 'white', color = 'black') +
  geom_sf(data=lixo2.sf,color='blue',size=1) +
  theme_void()
```

### Utilizando as informa√ß√µes dos casos (pontos) + do lixo (ponto) + popula√ß√£o de cada setor censit√°rio (mapa tem√°tico)

```{r, echo=T,  out.width="70%"}
# Adiciona categorias para legenda
lixo$tipo <- "Lixo"
casos.sf$tipo <- "Caso"

ggplot(setor.sf) + 
  geom_sf(aes(fill=pop)) + 
  geom_sf(data = casos.sf, color='red',size = 0.7, aes(colour = "Caso"), 
          show.legend = "point") +
  geom_sf(data = lixo2.sf, color = 'salmon', size = 1, aes(colour = "Lixo"), 
          show.legend = "point") +
  scale_fill_distiller(palette = "PuBu", direction = 1) +
  scale_colour_manual(values = c("Caso" = "red", "Lixo" = "salmon")) +
  theme_minimal()
```
### Construindo os buffers

* Ser√£o constru√≠dos buffers com raio de 500 metros ao redor de cada ponto de coleta de lixo. Essa abordagem permite analisar se os casos de dengue ocorrem dentro desse per√≠metro, ou seja, a at√© 500 metros dos pontos de coleta. O objetivo √© investigar se existe uma rela√ß√£o entre a proximidade desses locais e a ocorr√™ncia de casos de dengue.

**Buffers:** S√£o pol√≠gonos que contornam um objeto a uma determinada dist√¢ncia. Sua principal fun√ß√£o √© materializar os conceitos de ‚Äúperto‚Äù e ‚Äúlonge‚Äù.

```{r, echo=T,  out.width="70%"}
lixo_buffer <- st_buffer(lixo2.sf, 500) 

# Adiciona categorias para legenda
lixo_buffer$tipo <- "Lixo"
casos.sf$tipo <- "Caso"

ggplot(setor.sf) + 
  geom_sf(aes(fill = pop)) + 
  geom_sf(data = lixo_buffer, aes(color = tipo), fill = "transparent", size = 0.4) +
  geom_sf(data = casos.sf, aes(color = tipo), size = 0.7) +
  scale_fill_distiller(palette = "PuBu", direction = 1) +
  scale_color_manual(values = c("Caso" = "red", "Lixo" = "gray")) +
  theme_minimal()

```

### Representando os casos e o lixo de forma interativa com o a biblioteca `tmap`

```{r, echo=T,  out.width="90%"}
library(tmap)


tmap_mode("view") # modo interativo (Leaflet)
# tmap_mode("plot") # modo est√°tico (p/ publica√ß√£o)

# Constr√≥i o mapa
tm_shape(setor.sf) + tm_borders("black") +
  tm_shape(casos.sf) + tm_dots(col = "red", palette = "red") +
  tm_shape(lixo.sf) + tm_dots(col = "green", palette = "green") +
  tm_shape(lixo_buffer) + tm_borders(col = "blue")

```

### Convertendo o dado de pontos (padr√£o pontual) para dados de √°rea

```{r, echo=T}
library(sf)
library(dplyr)

# Conta casos confirmados (CLASSI_FIN == 1) por setor
casos <- casos.sf |>
  filter(CLASSI_FIN == 1) |>        # Filtra apenas casos confirmados
  mutate(contador = 1) |>          # Adiciona coluna de contagem
  st_join(setor.sf, join = st_within) |>  # Une os casos aos setores (dentro do pol√≠gono)
  group_by(ID) |>                 # Agrupa por ID do setor
  summarise(casos = sum(contador, na.rm = TRUE)) |> # Conta casos por setor
  st_drop_geometry()  ## remove atributos de geometria


# N√∫mero de dep√≥sitos de lixo por setor (sem geometria)
lixo <- lixo.sf |>
  mutate(contador = 1) |>                      # Adiciona coluna de contagem
  st_join(setor.sf, join = st_within) |>       # Junta pontos aos setores onde est√£o contidos
  group_by(ID) |>                              # Agrupa por setor
  summarise(lixo = sum(contador, na.rm = TRUE)) |>  # Soma os dep√≥sitos por setor
  st_drop_geometry()                           # Remove geometria


# Inserindo as contagens de lixo e casos confirmados na geometria dos setores
setor.sf <- setor.sf |>
  left_join(lixo, by = "ID") |>    # Junta a contagem de dep√≥sitos de lixo por setor
  left_join(casos, by = "ID")      # Junta a contagem de casos confirmados por setor

```


### Plotando o mapa tem√°tico dos casos por setor censit√°rio

```{r, echo=T,  out.width="70%"}
plot(setor.sf['casos'])
```

### Plotando o mapa tem√°tico dos pontos de coleta de lixo por setor censit√°rio

```{r, echo=T,  out.width="70%"}
plot(setor.sf['lixo'])
```

### Calculando a taxa de incid√™ncia e plotando o mapa tem√°tico dos pontos de coleta de lixo por setor censit√°rio

```{r, echo=T,  out.width="70%"}
setor.sf$tx <- (setor.sf$casos/setor.sf$pop) * 1000
setor.sf$tx[is.na(setor.sf$tx)] <- 0 # Transformando os missings em zero

summary(setor.sf$tx)
```

### Plotando a distribui√ß√£o da incid√™ncia em Dourados/MS

```{r, echo=T,  out.width="70%"}
library(wesanderson)
pal <- wes_palette("Moonrise3", 20, type = "continuous")

ggplot(setor.sf) + 
  geom_sf(aes(fill = tx), color = 'black') +
  scale_fill_gradientn(colours = pal) +
  ggtitle("Taxa de incid√™ncia de Dengue") + 
  theme_void()
```

### Kernel por atributos

- Vamos plotar o kernel por atributos referente a taxa de incid√™ncia de dengue em Dourados/MS.

- Primeiramente √© necess√°rio dissolver os pol√≠gonos em formato sf para obter o contorno. Nesse caso queremos preservar o atributo AREA

```{r, echo=T,  out.width="70%"}
dourados.contorno <- st_union(setor.sf)
plot(dourados.contorno)
```
- Agora iremos converter o contorno geogr√°fico da cidade de Dourados (um pol√≠gono `sf`) para o formato `owin `da classe `spatstat`, que √© usado para an√°lise espacial de padr√µes de pontos.

```{r, echo=T,  out.width="70%"}
dourados.w <- as.owin(st_geometry(dourados.contorno))
```

#### Extraindo os centr√≥ides dos pol√≠gonos em Dourados/MS

```{r, echo=T,  out.width="70%"}
centroides <- st_centroid(st_geometry(setor.sf))

# Transformando em os centr√≥ides em formato sp (spatstat)
centroides.sp <- as.data.frame(as_Spatial(centroides))
names(centroides.sp) <- c('X','Y')

plot(centroides.sp)
```

### Colocando os pontos no formato sp

```{r, echo=T,  out.width="70%"}
centroides.ppp <- ppp(centroides.sp$X,centroides.sp$Y, dourados.w)

plot(centroides.ppp,pch=19,cex=0.5)
```

### Construindo o kernel por atributo da taxa de detec√ß√£o

```{r, echo=T,  out.width="70%"}
kernel.tx <- density(centroides.ppp, 500, weights = setor.sf$tx, scalekernel = TRUE)
plot(kernel.tx)
```

::: box-dica2

- `centroides.ppp`:	Objeto do tipo ppp com os pontos centrais (centroides) dos setores.
500	Largura de banda (bandwidth), ou seja, o alcance de suaviza√ß√£o da fun√ß√£o kernel, neste caso 500 metros (ou unidades do sistema).

- `weights = setor.sf$tx`: Peso de cada ponto (setor), neste caso uma vari√°vel chamada tx, que provavelmente representa uma taxa (ex: incid√™ncia por popula√ß√£o).

- `scalekernel = TRUE`:	Faz a fun√ß√£o kernel se ajustar automaticamente √† soma total dos pesos, preservando a escala da densidade ponderada.
:::

### Construindo a matriz de vizinhan√ßa para verificar a autocorrela√ß√£o espacial

```{r, echo=T,  out.width="70%"}
library(spdep)
viz <- poly2nb(setor.sf)
viz 
```

::: box-dica2

- `setor.sf` √© um objeto do tipo sf com pol√≠gonos (setores).

- `poly2nb()` (polygon to neighbors) calcula quais pol√≠gonos s√£o vizinhos, ou seja, compartilham ao menos um lado ou ponto de fronteira (por padr√£o).

- `viz` √© um objeto do tipo nb ("neighbors list") ‚Äî uma lista onde cada item cont√©m os √≠ndices dos setores vizinhos ao setor correspondente.

:::

* Iremos precisar da coordenadas dos centr√≥ides para montar a malha de conectividade.

```{r, echo=T,  out.width="70%"}
setor.sp <- as(setor.sf, 'Spatial') # convertendo em formato sp
coord <- coordinates(setor.sp) # coordenadas dos centroidas dos poligonos de dourados
class(setor.sp)
```

### Verificando a malha de conectividade da vizinhan√ßa de Dourados/MS

```{r, echo=T}
viz.sf <- as(nb2lines(viz, coords = coord), 'sf')
viz.sf <- st_set_crs(viz.sf, st_crs(setor.sf))
```

::: box-dica2
- `st_set_crs()` define o sistema de refer√™ncia de coordenadas (CRS) do objeto `viz.sf`.

- Ele est√° copiando o CRS do objeto `setor.sf`, garantindo que os dois objetos estejam no mesmo sistema de coordenadas.
:::

```{r, echo=T,  out.width="70%"}
# Plotando o grafo de conectividade por contiguidade
mapa.viz <- ggplot(setor.sf) + 
  geom_sf(fill = 'lightpink', color = 'white') +
  geom_sf(data = viz.sf) +
  theme_minimal() +
  ggtitle("Vizinhan√ßa por \n conectividade") +
  ylab("Latitude") +
  xlab("Longitude")
mapa.viz
```

### Obtendo a correla√ß√£o da taxa de incid√™ncia de dengue Dourados/MS

- Convertendo a estrutura criada por `poly2nb(setor.sf)` um formato que fun√ß√µes como `moran.test`.

```{r, echo=T}
pesos.viz <- nb2listw(viz)
moran.test(setor.sf$tx, pesos.viz)
```

Podemos observar que existe uma forte autocorrela√ß√£o espacial positiva na vari√°vel `tx`, ou seja, valores semelhantes est√£o espacialmente agrupados. Em outras palavras, setores com valores altos de `tx` tendem a estar pr√≥ximos de outros setores com valores igualmente altos (e o mesmo vale para valores baixos). Esse padr√£o n√£o √© aleat√≥rio, j√° que o p-valor √© muito pequeno, rejeitando a hip√≥tese nula de aus√™ncia de autocorrela√ß√£o espacial.

### Plotando o correlograma

- O correlograma espacial de *Moran‚Äôs I* que voc√™ gerou est√° te mostrando como a autocorrela√ß√£o espacial da vari√°vel `tx` varia conforme o "distanciamento" espacial entre os setores.

```{r, echo=T}
correl <- sp.correlogram(viz, setor.sf$tx, order = 8, method = "I")
correl
```

-A tabela consiste:

  i) `estimate`: o valor observado de Moran‚Äôs I.

  ii) `expectation`: valor esperado sob aleatoriedade (‚âà 0).

  iii) `Pr(I)`: p-valor de signific√¢ncia para cada lag.


```{r, echo=T,  out.width="80%"}
plot(correl)
```


- Nesse gr√°fico podemos observar:

  i) O eixo y mostra o valor de Moran‚Äôs I para cada lag.

  ii) As barras de erro indicam o intervalo de confian√ßa do Moran‚Äôs I em cada lag.

- Podemos compluir ent√£o que:

  * Lag 1 (vizinhos imediatos): Moran‚Äôs I = 0.5367, altamente significativo (*p < 0.001*) $\rightarrow$ forte autocorrela√ß√£o espacial positiva.

  * Lags 2 e 3: valores positivos e ainda significativos $\rightarrow$ padr√£o espacial persiste at√© o terceiro n√≠vel de vizinhan√ßa.

  * Lags 4 a 8: valores negativos ou pr√≥ximos de zero, com signific√¢ncia decrescente ou aus√™ncia de signific√¢ncia $\rightarrow$ a autocorrela√ß√£o desaparece ou se inverte √† medida que a dist√¢ncia aumenta.

### Mapeando os pol√≠gonos que tiveram os p-valores mais significativos no Moran Local.

```{r, echo=T,  out.width="70%"}
setor.sf$pval <- localmoran(setor.sf$tx, pesos.viz)[,5]

tm_shape(setor.sf) + 
  tm_polygons(
    col = "pval",
    title = "p-valores",
    breaks = c(0, 0.01, 0.05, 0.10, 1),
    style = "fixed",
    palette = "-Oranges",
    border.col = "grey"
  )

```

### Moran Local (Lisa Map) da taxa de incid√™ncia Dourados/MS

```{r, echo=T}
resI <- localmoran.sad(lm(setor.sf$tx ~ 1), 1:length(viz), viz, style = "W")
summary(resI)[1:10,]
```

::: box-dica2 

- A fun√ß√£o `localmoran.sad()` calcula o Moran Local `(I·µ¢)` e algumas outras estat√≠sticas associadas para cada pol√≠gono (setor).

- `lm(setor.sf$tx ~ 1)`:  cria um modelo linear sem preditores (apenas o intercepto), ou seja, considera a vari√°vel `tx` como resposta a ser analisada.

- `1:length(viz)`: identifica o √≠ndice de cada √°rea/setor.

- `viz`: √© a estrutura de vizinhan√ßa (do tipo `nb`), que define quem √© vizinho de quem.

- `style = "W"`: define o estilo de normaliza√ß√£o dos pesos espaciais (padroniza√ß√£o row-standardized).

:::

- A est√° mostrando:

  * `Local Morans I`:	Valor do I de Moran local `(I·µ¢)`, indicando se o valor do setor e seus vizinhos s√£o semelhantes (positivo) ou diferentes (negativo).
  
  * `Stand. dev. (N)`:	Desvio padr√£o padronizado da estat√≠stica de Moran local.
  
  * `Pr. (N)`:	p-valor do teste de signific√¢ncia para o valor de `I·µ¢` (baseado na dist. normal).
  
  * `Saddlepoint`:	Valor do I de Moran local corrigido.
  
```{r, echo=T,  out.width="70%"}
setor.sf$MoranLocal <- summary(resI)[,1] 

library(scales)

ggplot(setor.sf) + 
  geom_sf(aes(fill = MoranLocal), color = 'black') +
  scale_fill_gradientn(colours=c("blue", "white", "red"), 
                       values=rescale(c(min(setor.sf$MoranLocal), 0,   max(setor.sf$MoranLocal))), guide="colorbar") + 
  ggtitle("Moran local") + 
  theme_void()
```


Neste mapa, podemos observar:

- Valores altos de Local Morans I com p-valor pequeno indicam clusters estatisticamente significativos:

  * Positivo + significativo $\rightarrow$ cluster alto-alto ou baixo-baixo.

  * Negativo + significativo $\rightarrow$ outlier (ex: um valor alto cercado por baixos, ou o contr√°rio).

### LISA Map

  
```{r, echo=T}
library(spdep)

#  Convertendo uma estrutura de vizinhan√ßa (objeto nb) em uma matriz de pesos espaciais padronizada
w <- nb2listw(viz, style = "W")

# Matriz de pesos espaciais padronizada (row-standardized)
resI <- localmoran(setor.sf$tx, nb2listw(viz, style = "W"))

# Armazena estat√≠sticas no objeto espacial
setor.sf$Ii       <- resI[,1]   # valor de Moran Local
setor.sf$pvalue   <- resI[,5]   # p-valor

# Valor padronizado da vari√°vel tx
setor.sf$z_tx <- scale(setor.sf$tx)[, 1]

# M√©dia dos vizinhos (lagged value)
lag_tx <- lag.listw(w, setor.sf$z_tx)

# Classifica√ß√£o dos tipos de associa√ß√£o local dos clusters
setor.sf$cluster_type <- "N√£o significativo"

setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx > 0 & lag_tx > 0] <- "Alto-Alto"
setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx < 0 & lag_tx < 0] <- "Baixo-Baixo"
setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx > 0 & lag_tx < 0] <- "Alto-Baixo"
setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx < 0 & lag_tx > 0] <- "Baixo-Alto"


```
  
```{r, echo=T,  out.width="80%"}
library(tmap)

# Modo est√°tico (ideal para relat√≥rios impressos ou PDF)
tmap_mode("plot")

# Tema visual limpo com fundo branco
tmap_style("white")

# Gera√ß√£o do mapa LISA
tm_shape(setor.sf) +
  tm_fill(
    col = "cluster_type",
    palette = c(
      "Alto-Alto"         = "#E60000",  # vermelho forte
      "Baixo-Baixo"       = "#0033CC",  # azul escuro
      "Baixo-Alto"        = "#9999FF",  # azul claro
      "Alto-Baixo"        = "#FF9999",  # rosa claro
      "N√£o significativo" = "#FFFFFF"   # branco
    ),
    title = "Cluster Local (LISA)",
    legend.is.portrait = TRUE
  ) +
  tm_borders(col = "gray40", lwd = 0.4) +
  tm_layout(
    main.title = "Mapa LISA - Clusters Locais da Taxa de Incid√™ncia",
    main.title.size = 1.2,
    legend.outside = TRUE,
    frame = FALSE,
    bg.color = "white"
  )

```
  
# **Aplica√ß√£o IV:** Dengue em Dourados/MS - Parte 2: Modelagem (Modelos Linear, CAR e GWR)

### Ajustando o modelo de regress√£o linear simples.

```{r, echo=T,  out.width="70%"}
# Transformando os missings em zero
setor.sf$lixo[is.na(setor.sf$lixo)] <- 0  

dourados.lm <- lm(tx ~ lixo, data = setor.sf)
summary(dourados.lm)
```

### Checando os residuos para verificar a presen√ßa de autocorrela√ß√£o.

```{r, echo=T,  out.width="70%"}
dourados.lm$lmresid <- residuals(dourados.lm)
moran.test(dourados.lm$lmresid, pesos.viz)
```

### Ajustando o modelo CAR (Spatial Error Model)

```{r, echo=T,  out.width="70%"}
library(spatialreg)
dourados.car <- errorsarlm(tx ~ lixo, data = setor.sf, listw = pesos.viz)
summary(dourados.car)
```

### Checando os residuos para verificar a presen√ßa de autocorrela√ß√£o

```{r, echo=T,  out.width="70%"}
dourados.car$carresid <- residuals(dourados.car)
moran.test(dourados.car$carresid, pesos.viz)
```

### Ajustando o modelo GWR (Geographically Weighted Regression)

```{r, echo=T,  out.width="70%"}
# Biblioteca para ajustar o modelos GWR
library(spgwr)

# Estimando a largura de banda ‚Äúideal‚Äù para o kernel
GWRbanda <- gwr.sel(tx ~ lixo, data = setor.sf, coords = cbind(centroides.sp$X, centroides.sp$Y), adapt = T)
```


```{r, echo=T,  out.width="70%"}
# Ajustando o modelo GWR
dourados.gwr = gwr(tx ~ lixo, data = setor.sf, coords = cbind(centroides.sp$X, centroides.sp$Y), adapt = GWRbanda, hatmatrix = TRUE, se.fit = TRUE)

dourados.gwr
```

```{r, echo=T,  out.width="70%"}
# Colocando a sa√≠da do modelo dentro de um objeto dataframe.
results <- as.data.frame(dourados.gwr$SDF)
head(results)
```

### Verificando a distribui√ß√£o dos coeficientes de regress√£o para a vari√°vel lixo

```{r, echo=T,  out.width="80%"}
hist(results$lixo)
abline(v = median(results$lixo), col = "red")
```

### Verificando a distribui√ß√£o dos *localR2*

```{r, echo=T,  out.width="80%"}
hist(results$localR2)
abline(v = median(results$localR2), col = "blue")
```

### Incorporando alguns par√¢metros de sa√≠da do modelo na tabela *setor.sf*

```{r, echo=T,  out.width="70%"}
setor.sf$coef.lixo <- results$lixo
setor.sf$localR2 <- results$localR2
setor.sf$pred.gwr <- results$pred
```

### Mapa dos coeficientes de regress√£o para a vari√°vel lixo

```{r, echo=T,  out.width="80%"}
map.lixo <- ggplot(setor.sf) + 
  geom_sf(aes(fill = coef.lixo), color = "black") +              scale_fill_gradientn(colours = pal) + ggtitle("Distribui√ß√£o dos coef. var. lixo") + 
  theme_void()
map.lixo

```

### Checando os residuos para verificar a presen√ßa de autocorrela√ß√£o para o modelo GWR.

```{r, echo=T,  out.width="70%"}
# Calculando os res√≠duos para o modelo GWR
results$residuos <- setor.sf$tx - results$pred

moran.test(results$residuos, pesos.viz)
```

### Mapeando os coeficientes de regress√£o para a vari√°vel lixo por significancia atrav√©s do teste de wald

```{r, echo=T,  out.width="100%"}
# Calculando a estat√≠stica de wald
setor.sf$wald.teste <- abs(results$lixo/results$lixo_se)
# Dicotomizando a estat√≠stica de wald
setor.sf$wald.teste <- ifelse(setor.sf$wald.teste < 2, 0, 1)


map.wald <- ggplot(setor.sf) + geom_sf(aes(fill = factor(wald.teste)), color = "black") + 
  scale_fill_manual(values = c("white", "purple"), labels = c("< 2", ">= 2"), name = "Wald") + 
  ggtitle("Coef. lixo significativos") + theme_void()


library(gridExtra)
grid.arrange(map.lixo, map.wald, ncol = 2)

```

### Mapa dos coeficientes de determina√ß√£o regionalizados ($R^2$ local).

```{r, echo=T,  out.width="90%"}
ggplot(setor.sf) + 
  geom_sf(aes(fill = localR2), color = "black") + scale_fill_gradientn(colours = pal) + 
  ggtitle("R¬≤ local") + theme_void()

```

### Verificando a distribui√ß√£o dos preditos.

```{r, echo=T,  out.width="100%"}
histdens <- function(x, titulo = "") {
  densi <- density(x)
  xli <- range(densi$x)
  yli <- range(densi$y)
  hist(x, col = "red", probability = T, xlim = xli, ylim = yli, main = titulo)
  lines(densi, lwd = 2)
  abline(v = median(x), lwd = 2, col = 4, lty = 2)
}

par(mfrow = c(2, 2))

hist.tx <- histdens(setor.sf$tx, "Tx Bruta")
hist.lm <- histdens(dourados.lm$fitted.values, "Pred LM")
hist.car <- histdens(dourados.car$fitted.values, "Pred CAR")
hist.gwr <- histdens(results$pred, "Pred GWR")
```

### Mapeando os valores observados e preditos dos modelos ajustados

```{r, echo=T,  out.width="100%"}
library(colorspace)  # 

setor.sf$brks <- cut(setor.sf$tx, include.lowest = TRUE, right = TRUE, breaks = c(-4, 
                                                                                  0, 2, 4, 10, 57), labels = c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))

tx.bruta <- ggplot(setor.sf) + geom_sf(aes(fill = brks), color = "black") + ggtitle("Taxa Bruta") + 
  scale_fill_discrete_sequential(palette = "Heat2", c1 = 80, c2 = 30, l1 = 30, 
                                 l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", drop = FALSE, name = "Taxa") + 
  theme_void()



setor.sf$brks.lm <- cut(dourados.lm$fitted.values, lowest = TRUE, right = TRUE, breaks = c(-4, 
                                                                                           0, 2, 4, 10, 57), labels = c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))


pred.lm <- ggplot(setor.sf) + geom_sf(aes(fill = brks.lm), color = "black") + ggtitle("Taxa Predita - LM") + 
  scale_fill_discrete_sequential(palette = "Heat2", c1 = 80, c2 = 30, l1 = 30, 
                                 l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", drop = FALSE, name = "Taxa") + 
  theme_void()

setor.sf$brks.car <- cut(dourados.car$fitted.values, lowest = TRUE, right = TRUE, 
                         breaks = c(-4, 0, 2, 4, 10, 57), labels = c("0", "0 - 2", "2 - 4", "4 - 10", 
                                                                     "> 10"))


pred.car <- ggplot(setor.sf) + geom_sf(aes(fill = brks.car), color = "black") + ggtitle("Taxa Predita - CAR") + 
  scale_fill_discrete_sequential(palette = "Heat2", c1 = 80, c2 = 30, l1 = 30, 
                                 l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", drop = FALSE, name = "Taxa") + 
  theme_void()

setor.sf$brks.gwr <- cut(results$pred, lowest = TRUE, right = TRUE, breaks = c(-4, 
                                                                               0, 2, 4, 10, 57), labels = c("0", "0 - 2", "2 - 4", "4 - 10", "> 10"))


pred.gwr <- ggplot(setor.sf) + geom_sf(aes(fill = brks.car), color = "black") + ggtitle("Taxa Predita - GWR") + 
  scale_fill_discrete_sequential(palette = "Heat2", c1 = 80, c2 = 30, l1 = 30, 
                                 l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", drop = FALSE, name = "Taxa") + 
  theme_void()

library(gridExtra)
grid.arrange(tx.bruta, pred.lm, pred.car, pred.gwr, ncol = 2)
```

### Comparando a distribui√ß√£o dos res√≠duos dos modelos ajustados

```{r, echo=T,  out.width="90%"}
library(vioplot)
vioplot(dourados.lm$residuals, dourados.car$residuals, results$residuos, names = c("LM", 
                                                                                   "CAR", "GWR"), col = "orange")
title("Gr√°ficos violinos da distribui√ß√£o dos res√≠duos")
```

### Mapeando os res√≠duos dos modelos ajustados

```{r, echo=T,  out.width="100%"}
library(colorspace)  # 

setor.sf$brks.res.lm <- cut(dourados.lm$residuals, include.lowest = TRUE, right = TRUE, 
                            breaks = c(-14, -5, -1, 1, 5, 52), labels = c("< -5", "-5 a -1", "0", "1 a 5", 
                                                                          "> 5"))

res.lm <- ggplot(setor.sf) + geom_sf(aes(fill = brks.res.lm), color = "black") + 
  ggtitle("Res√≠duos - LM") + scale_fill_discrete_sequential(palette = "Purple-Yellow", 
                                                            c1 = 80, c2 = 30, l1 = 30, l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", 
                                                            drop = FALSE, name = "Taxa") + theme_void()

setor.sf$brks.res.car <- cut(dourados.car$residuals, include.lowest = TRUE, right = TRUE, 
                             breaks = c(-14, -5, -1, 1, 5, 52), labels = c("< -5", "-5 a -1", "0", "1 a 5", 
                                                                           "> 5"))

res.car <- ggplot(setor.sf) + geom_sf(aes(fill = brks.res.car), color = "black") + 
  ggtitle("Res√≠duos - CAR") + scale_fill_discrete_sequential(palette = "Purple-Yellow", 
                                                             c1 = 80, c2 = 30, l1 = 30, l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", 
                                                             drop = FALSE, name = "Taxa") + theme_void()


setor.sf$brks.res.gwr <- cut(results$residuos, include.lowest = TRUE, right = TRUE, 
                             breaks = c(-14, -5, -1, 1, 5, 52), labels = c("< -5", "-5 a -1", "0", "1 a 5", 
                                                                           "> 5"))

res.gwr <- ggplot(setor.sf) + geom_sf(aes(fill = brks.res.gwr), color = "black") + 
  ggtitle("Res√≠duos - GWR") + scale_fill_discrete_sequential(palette = "Purple-Yellow", 
                                                             c1 = 80, c2 = 30, l1 = 30, l2 = 90, p1 = 0.2, p2 = 1.5, na.value = "grey75", 
                                                             drop = FALSE, name = "Taxa") + theme_void()


library(gridExtra)
grid.arrange(res.lm, res.car, res.gwr, ncol = 2)

```

# **Aplica√ß√£o V:** Geoestat√≠stica com dados de pluviosidade na cidade do Rio de Janeiro/RJ

### Biliotecas do R que ser√£o utilizadas

```{r, echo=T}
library(sf)
library(sp)
library(dplyr)
library(gstat)
library(lattice)
library(automap)
library(raster)
library(leaflet)
```

### Importando a tabela com a chuva acumulada m√©dia de 7 dias das √∫ltimas 24hs e 96hs das esta√ß√µes pluviom√©tricas da cidde do Rio de Janeiro

[Descri√ß√£o das Esta√ß√µes (Alerta Rio)](http://www.sistema-alerta-rio.com.br/dados-meteorologicos/info-estacoes/)

[Download Dados Pluviom√©tricos (Alerta Rio)](http://www.sistema-alerta-rio.com.br/dados-meteorologicos/download/dados-pluviometricos/)

```{r, echo=T}
pluvio <- read.csv("dados/chuva_rio/pluviosidade.csv", sep=";")
```

### An√°lise Gr√°fica Descritiva 

```{r, echo=T}
quantil <- quantile(pluvio$acumulado_24h, seq(0,1,0.2))
quantil
```

### Transformar os dados em um objeto espacial do R

* x - Longitude
* y - Latitude

```{r, echo=T}
sp::coordinates(pluvio) = ~ x + y
```

### An√°lise Gr√°fica Descritiva com os dados espaciais

```{r, echo=T,  out.width="90%"}
# Bubble plot
bubble(pluvio, "acumulado_24h", key.entries = quantil, pch=19, col="blue")
```

```{r, echo=T,  out.width="90%"}
# Point plot
spplot(pluvio['acumulado_24h'], scales=list(draw=T), key.space="right", colorkey=T)
```

### Modelando o variograma experimental (ou emp√≠rico)

- **width** - Dist√¢ncia m√©dia entre amostras ou dist√¢ncia dos lags
- **cutoff** - M√°xima dist√¢ncia

```{r, echo=T}
variogram.emp = variogram(acumulado_24h ~x+y, pluvio, width=1000, cutoff=20000)
variogram.emp
```

```{r, echo=T}
# Variogram plot
plot(variogram.emp, main = "Empirical variogram", pch = 19, col = "darkblue")
```

### Ajustando o semivariograma te√≥rico

- **Sill** - Semivari√¢ncia estrutural ou contribui√ß√£o (ponto m√°ximo que chega ao plato no eixo de y)
- **Range** - Alcance (ponto m√°ximo em x)
- **Nugget** - Efeito pepita, quando (y, 0)

```{r echo=F, fig.align="center", out.width= "70%", fig.show='hold'}
include_graphics('figuras/variograma_model.png')
```
[Fonte do gr√°fico](https://vsp.pnnl.gov/help/Vsample/Kriging_Variogram_Model.htm)


```{r, echo=T}
## 1) Modelo Linear
lin.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 240, model = "Lin",
                                     range = 5000, nugget = 10))

## 2) Modelo exponencial
exp.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 240, model = "Exp",
                                     range = 5000, nugget = 10))

## 3) Modelo gaussiano
gau.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 240, model = "Gau",
                                     range = 5000, nugget = 10))

## 3) Modelo wave
wav.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 240, model = "Wav",
                                     range = 5000, nugget = 10))
```

```{r, echo=T, out.width= "100%"}
plot.lin <- plot(variogram.emp, lin.fit, main = "Modelo Linear")
plot.exp <- plot(variogram.emp, exp.fit, main = "Modelo Exponencial")
plot.gau <- plot(variogram.emp, gau.fit, main = "Modelo Gaussiano")
plot.wav <- plot(variogram.emp, wav.fit, main = "Modelo Wave")
```

### Valida√ß√£o cruzada 

- **RMSE** (root mean squared error): √© a medida que calcula "a raiz quadr√°tica m√©dia" dos erros entre valores observados (reais) e predi√ß√µes (hip√≥teses).

```{r, echo=T}
## 1) Modelo Linear
cv.lin <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = lin.fit)
summary(cv.lin)
plot(cv.lin$var1.pred ~ cv.lin$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_lin <- lm(cv.lin$var1.pred ~ cv.lin$observed)
abline(lm_lin, col = "red", lwd = 2)
r2_lin = summary(lm_lin)$r.squared
rmse_lin = hydroGOF::rmse(cv.lin$var1.pred, cv.lin$observed)

## 2) Modelo exponencial
cv.exp <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = exp.fit)
summary(cv.exp)
plot(cv.exp$var1.pred ~ cv.exp$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_exp <- lm(cv.exp$var1.pred ~ cv.exp$observed)
abline(lm_exp, col = "red", lwd = 2)
r2_exp = summary(lm_exp)$r.squared
rmse_exp = hydroGOF::rmse(cv.exp$var1.pred, cv.exp$observed)

## 3) Modelo Gaussiano
cv.gau <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = gau.fit)
summary(cv.gau)
plot(cv.gau$var1.pred ~ cv.gau$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_gau <- lm(cv.gau$var1.pred ~ cv.gau$observed)
abline(lm_gau, col = "red", lwd = 2)
r2_gau = summary(lm_gau)$r.squared
rmse_gau = hydroGOF::rmse(cv.gau$var1.pred, cv.gau$observed)

## 4) Modelo Wave
cv.wav <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = wav.fit)
summary(cv.wav)
plot(cv.wav$var1.pred ~ cv.wav$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_wav <- lm(cv.wav$var1.pred ~ cv.wav$observed)
abline(lm_wav, col = "red", lwd = 2)
r2_wav = summary(lm_wav)$r.squared
rmse_wav = hydroGOF::rmse(cv.wav$var1.pred, cv.wav$observed)
```

```{r, echo=T}
# Criando uma tabela das estat√≠stica de R2 e RMSE
df.r2 <- data.frame(r2_lin, r2_exp, r2_gau, r2_wav)
df.rmse <- data.frame(rmse_lin, rmse_exp, rmse_gau, rmse_wav)
tabela <- data.frame(cbind(t(df.r2), t(df.rmse)))
colnames(tabela) <- c('R2', 'RMSE')
rnames <- gsub('r2_','', rownames(tabela)) # remove o prefixo r2 dos nomes das linhas
rownames(tabela) <- rnames # substitui o nome das linhas simplificadas na tab original
tabela
```

### Criando os grids do contorno da cidade do Rio de Janeiro para intermpola√ß√£o

```{r, echo=T}
# Importando o contorno do Rio
contorno.rio <- shapefile('dados/chuva_rio/MUNIC_2K_2022_IPP_SIRGAS.shp')
```

```{r, echo=T}
# Criando grade para interpolacao com a  resolucao de 50m
r <- raster(contorno.rio, res = 50)

# Criando um objeto formato raster
rp <- rasterize(contorno.rio, r, 0) 

# Trasnsformando o objeto raster no formato SpatialPixelsDataFrame
grid <- as(rp, "SpatialPixelsDataFrame") 
sp::plot(grid)
```

### Krigagem

```{r, echo=T}
# Colocando os dados de chuva e o grid na mesma projecao
sp::proj4string(pluvio) = CRS(proj4string(contorno.rio))

mapa_chuva_lin <- krige(acumulado_24h ~1, pluvio, grid, model =lin.fit)
mapa_chuva_exp <- krige(acumulado_24h ~1, pluvio, grid, model =exp.fit)
mapa_chuva_gau <- krige(acumulado_24h ~1, pluvio, grid, model =gau.fit)
mapa_chuva_wav <- krige(acumulado_24h ~1, pluvio, grid, model =wav.fit)
```

```{r, echo=T, out.width= "100%"}
plot.lin <- plot(mapa_chuva_lin, main = "Modelo Linear")
plot.exp <- plot(mapa_chuva_exp, main = "Modelo Exponencial")
plot.gau <- plot(mapa_chuva_gau, main = "Modelo Gaussiano")
plot.wav <- plot(mapa_chuva_wav, main = "Modelo Wave")

```

### Auto Krige 

```{r, echo=T}
# Modelando
auto.krige = autoKrige(acumulado_24h~x+y, pluvio, grid, model = 'Exp')
summary(auto.krige)
```

```{r, echo=T}
# Valida√ß√£o cruzada
auto.krige.cv <- autoKrige.cv(acumulado_24h~x+y, pluvio, model = 'Exp')
summary(auto.krige.cv)
```

### Convertendo para o formato raster - auto krige

```{r, echo=T}
raster_chuva <- raster(auto.krige$krige_output)
plot(raster_chuva)
```

- Caso queira salvar a imagem raster em um arquivo formato geotiff para ler em algum SIG por exemplo:
  
  ```{r, echo=T}
# Exportando o objeto da imagem
writeRaster(raster_chuva,
            filename = 'dados/chuva_rio/chuva_auto.tiff',
            format = 'GTiff',
            overwrite = T)

# Importando de volta para o R
raster_chuva <- raster("dados/chuva_rio/chuva_auto.tiff")
```

### Fazendo o mapa interativo com as esta√ß√µes

```{r, echo=T}
# Importando os dados referente as estat√ß√µes pluviom√©tricas
estacoes.sf <- read_sf('dados/chuva_rio/Estac_C3_B5es_Alerta_Rio.shp')

# Convertendo UTM para Lat Long das estacoes
estacoes.longlat <- st_transform(estacoes.sf, "+proj=longlat +ellps=WGS84 +datum=WGS84")
estacoes.longlat$coords <- st_coordinates(estacoes.longlat)
estacoes.longlat$X <- estacoes.longlat$coords[,1]
estacoes.longlat$Y <- estacoes.longlat$coords[,2]
```

```{r, echo=T}
# Importando a malha de bairros
bairros.sf <- read_sf('dados/chuva_rio/BAIRROS_2K_2022_IPP_SIRGAS.shp')

# Convertendo UTM para Lat Long a malha dos bairros
bairros.longlat <- st_transform(bairros.sf, "+proj=longlat +ellps=WGS84 +datum=WGS84")
```

```{r, echo=T}
# Convertendo o raster da chuva para lat long 
raster_chuva_longlat <- projectRaster(raster_chuva, crs = CRS("+proj=longlat +datum=WGS84"))
```

```{r, echo=T}
# Definindo Paleta de cores da superf√≠cie interpolada da chuva
pal <- colorNumeric(c("#000066", "#00c8f8", "#F0E68C","#FFFF00", "#FF8C00"), values(raster_chuva_longlat), na.color = "transparent", reverse = T)
```

```{r, echo=T, out.width= "100%"}
# Construindo o mapa interativo via leaflet

leaflet(data = estacoes.longlat, options = leafletOptions(
  attributionControl=FALSE)) |> 
  # addTiles() |>
  addProviderTiles("CartoDB.Positron", group = "Ruas") |>
  addProviderTiles("Esri.WorldImagery", options = providerTileOptions(opacity = 0.7), group = "Sat√©lite") |> 
  addProviderTiles(providers$CartoDB.Voyager, group = "Voyager") |>
  addProviderTiles(providers$Stamen.Toner, group = "Toner") |>
  setView(lng = -43.42, lat = -22.90, zoom = 10.4) |>
  # addProviderTiles(providers$CartoDB.Voyager) |>
  addMarkers(~X, ~Y, popup = ~as.character(est), label = ~as.character(est),
             group = "Esta√ß√µes") |>
  ############## Pol√≠gonos dos Bairros ################
addPolygons(data=bairros.longlat,
            weight = 3,
            color = "darkblue",
            smoothFactor = 1,
            fill = FALSE,
            labelOptions = labelOptions(
              style = list("font-weight" = "normal", padding = "3px 8px"),
              textsize = "13px",
              direction = "auto"), 
            group = "Bairros") |>
  ########## Adicionando o raster  #########################
addRasterImage(raster_chuva_longlat, colors = pal, opacity = 0.8,
               group = "Chuva: 1 semana") %>%
  leaflet::addLegend(pal = pal, values = values(raster_chuva_longlat),
                     title = "Chuva Acumulada - 1 semana", group = "Chuva: 1 semana") |>
  ############## Controle das layers (botoes) ################
addLayersControl(
  baseGroups = c("Voyager", "Ruas", "Sat√©lite", "Toner"),
  overlayGroups = c("Esta√ß√µes", "Bairros",  "Chuva: 1 semana"),
  options = layersControlOptions(collapsed = FALSE),
  position = "bottomleft") |>
  ########## Desabilitando os grupos ################
hideGroup(group = c("Bairros"))
```



# Bibliografia sugerida

* Druck, S.; Carvalho, M.S.; C√¢mara, G.; Monteiro, A.V.M. (eds). [An√°lise Espacial de Dados Geogr√°ficos](http://www.dpi.inpe.br/gilberto/livro/analise/). Bras√≠lia, EMBRAPA, 2004.

* Interactive Spatial Data Analysis by Trevor C. Bailey , Anthony C. Gatrell Routledge, 1995

* Applied Spatial Statistics for Public Health Data; Lance A. Waller, Carol A. Gotway Wiley-Interscience 1St ed. 2004

* Applied Spatial Data Analysis with R; Roger S. Bivand, Edzer Pebesma , Virgilio Gomez-Rubio Springer; Edi√ß√£o: 2nd ed. 2013

* Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow. [Geocomputation with R](https://geocompr.robinlovelace.net/), 2021.

* Spatial Statistics Workbook of Department of Criminology at the University of Manchester by Reka Solymosi and Juanjo Medina [Crime Mapping in R](https://maczokni.github.io/crime_mapping_textbook/)

* Spatial Data Science with R
[Spatial Data Science with R](https://rspatial.org/raster/index.html)

* GeoComputation and Spatial Analysis practicals by Lex Comber
[On-line Book](https://bookdown.org/lexcomber/GEOG3195/)

* GEOG5917 Big Data & Consumer Analytics - RStudio Practicals by Lex Comber
[On-line Book](https://bookdown.org/lexcomber/GEOG5917/)