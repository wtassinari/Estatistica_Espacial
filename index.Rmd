---
title: "Especializa√ß√£o em Estat√≠stica Aplicada (PPGEAD): M√≥dulo de Estat√≠stica Espacial"
author: |
  | Wagner Tassinari 
  |
date: "2025"
output:
  rmdformats::robobook:
    css: style.css
    highlight: kate
---

```{r setup, include=FALSE}
library(knitr)
library(rmdformats)

## Global options
options(max.print="75")
knitr::opts_chunk$set(echo=FALSE,
               cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               cache.lazy=FALSE)
knitr::opts_knit$set(width=75)

```

```{r klippy}
# Insert copy to clipboard buttons in HTML documents
# remotes::install_github("rlesur/klippy")
# xfun::install_github("rlesur/klippy")
# remotes::install_github("spatstat/spatstat.core")
klippy::klippy(
  lang = c("r", "markdown"),
  all_precode = FALSE,
  position = c("top", "right"),
  color = "navyblue",
  tooltip_message = "copiar c√≥digo",
  tooltip_success = "copiado!"
)

```

```{r}
## Color Format
colFmt <- function(x,color) {
  
  outputFormat <- knitr::opts_knit$get("rmarkdown.pandoc.to")
  
  if(outputFormat == 'latex') {
    ret <- paste("\\textcolor{",color,"}{",x,"}",sep="")
  } else if(outputFormat == 'html') {
    ret <- paste("<font color='",color,"'>",x,"</font>",sep="")
  } else {
    ret <- x
  }

  return(ret)
}
```


```{r echo=F, fig.align="center", out.width="90%", fig.asp=0.5}

include_graphics('figuras/rural2.png')
```

Fonte: [Storymap UFRRJ](https://uploads.knightlab.com/storymapjs/900b7a9343559e19eae3c9dffed08d71/ufrrj/draft.html)



# Introdu√ß√£o √† An√°lise Estat√≠stica Espacial

## O que √© An√°lise Estat√≠stica Espacial ?

- S√£o m√©todos estat√≠sticos que levam em considera√ß√£o a localiza√ß√£o espacial do fen√¥meno estudado;

- Segundo Bailey & Gatrell (1995), *"A an√°lise estat√≠stica espacial √© aplicada quando os dados possuem localiza√ß√£o geogr√°fica e quando o arranjo espacial desses dados √© considerado relevante para a an√°lise e interpreta√ß√£o dos resultados."*

- A primeira quest√£o a ser considerada √©: os dados seguem um padr√£o aleat√≥rio ou indicam a presen√ßa de agrega√ß√µes bem definidas (*clusters*) ?

```{r echo=F, fig.align="center", out.width= "80%", fig.show='hold'}
knitr::include_graphics('figuras/Cluster.png')
```

## Origem da Estat√≠stica Espacial

O uso de dados espaciais na sa√∫de teve um marco hist√≥rico com John Snow, que em 1854 mapeou um surto de c√≥lera em Londres, desafiando a teoria miasm√°tica* ao identificar a contamina√ß√£o da √°gua como causa da doen√ßa. Ao mapear as mortes por c√≥lera no Soho, John Snow identificou um foco ao redor da bomba de √°gua da Broad Street, apoiando sua hip√≥tese de transmiss√£o h√≠drica.

<span style="font-size: 10px;">
*"Miasm√°tica" refere-se √† teoria que defendia que as doen√ßas eram causadas por vapores ou odores nocivos (miasmas) provenientes de mat√©ria org√¢nica em decomposi√ß√£o, particularmente em √°reas √∫midas ou com m√° higiene.
</span>


```{r echo=F, fig.align="center", out.width= "80%", fig.show='hold'}
include_graphics('figuras/snow2_2019.png')
```
<span style="font-size: 11px;">
- Mapeamento dos casos de col√©ra ($\bullet$) e as bombas de √°gua (X) em Londres, 1854.
</span>

- Dr. John Snow (1813-1858) $\rightarrow$ Considerado pai da Epidemiologia Moderna

```{r echo=F, fig.align="center", out.width= "40%", fig.show='hold'}
include_graphics('figuras/snow_2019.png')
```
\

A imagem mostra homenagens a John Snow em Soho, Londres: um retrato na fachada de um pub, a r√©plica da bomba de √°gua da Broad Street, e uma placa que marca a descoberta de que a c√≥lera era transmitida pela √°gua contaminada em 1854.

## Objetivos da Estat√≠stica Espacial

1) Investigar padr√µes espaciais e espa√ßo-temporais, por meio de t√©cnicas como a An√°lise Explorat√≥ria de Dados Espaciais (AEDE) e medidas de correla√ß√£o espacial, visando identificar estruturas, agrupamentos e depend√™ncias nos dados geogr√°ficos.

2) Modelar fen√¥menos espaciais utilizando modelos estat√≠sticos apropriados, como regress√µes espaciais (ex: SAR, CAR, GWR) e modelos espa√ßo-temporais, que permitem controlar efeitos de vizinhan√ßa (depend√™ncia espacial) e heterogeneidade geogr√°fica, com o objetivo de explicar e/ou prever fen√¥menos influenciados pela localiza√ß√£o geogr√°fico.

## Depend√™ncia Espacial ou Autocorrela√ß√£o Espacial

- Segundo Cressie (1991), embora a suposi√ß√£o de independ√™ncia entre observa√ß√µes torne a teoria estat√≠stica mais trat√°vel, modelos que incorporam *depend√™ncia estat√≠stica* costumam ser mais realistas, especialmente em contextos espaciais. Nesse tipo de dado, a *depend√™ncia entre observa√ß√µes ocorre em m√∫ltiplas dire√ß√µes* e tende a diminuir conforme aumenta a dist√¢ncia entre os locais amostrados. Em outras palavras, valores pr√≥ximos no espa√ßo tendem a ser mais semelhantes entre si do que valores distantes, o que caracteriza a autocorrela√ß√£o espacial.

- *"Todas as coisas se parecem, por√©m coisas mais pr√≥ximas tendem a ser mais semelhantes do que aquelas mais distantes."*  (Tobler, 1979). `r colFmt(" **Tamb√©m conhecida como $1^a$ Lei da Geografia**",'red')`

## Tipologia dos Dados Espaciais

Os dados espaciais podem ser classificados segundo diferentes categorias, com base na natureza estoc√°stica de suas observa√ß√µes e na forma como a informa√ß√£o geogr√°fica √© representada. Essa tipologia orienta a escolha de m√©todos estat√≠sticos apropriados para an√°lise.

Segundo Noel Cressie (1993), a estat√≠stica espacial pode ser dividida em tr√™s grandes √°reas:

  i) `r colFmt(" **Dados de Processos Pontuais ou Padr√µes Pontuais**",'darkmagenta')`: As observa√ß√µes ocorrem de maneira aleat√≥ria no espa√ßo, como casos de uma doen√ßa, localiza√ß√£o de crimes ou ocorr√™ncia de focos de queimadas. O objetivo √© entender padr√µes de agrupamento, dispers√£o ou aleatoriedade desses pontos.

  ii) `r colFmt(" **Dados de Geoestat√≠stica**",'darkmagenta')`: Refere-se as observa√ß√µes que apresentam um atributo mensurav√©l em localiza√ß√µes cont√≠nuas ou irregulares (por exemplo, temperatura, polui√ß√£o, altitude, teor de argila). Nesses casos, h√° interesse na depend√™ncia espacial entre valores pr√≥ximos e na interpola√ß√£o de valores para locais n√£o amostrados, por meio de m√©todos como krigagem.

  iii) `r colFmt(" **Dados de √Årea**",'darkmagenta')`: Representam fen√¥menos agregados por unidades geogr√°ficas, como munic√≠pios, distritos ou setores censit√°rios. As an√°lises incluem autocorrela√ß√£o espacial (ex: I de Moran) e modelos de regress√£o espacial adaptados a dados agregados.

<!-- Existem m√©todos estatƒ±ÃÅsticos diferentes para descrever ou analisar estes tipos de dados. Exemplo: -->

<!-- ```{r echo=F, fig.align="center", out.width= "75%", fig.show='hold'} -->
<!-- include_graphics('figuras/slide4.jpg') -->

<!-- ``` -->

# Padr√µes Pontuais

* O principal interesse est√° no conjunto de coordenadas geogr√°ficas representando as localiza√ß√µes exatas de eventos.

```{r echo=F, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="50%", comment=NA}
knitr::include_graphics('figuras/coordenadas.png')
```

## Exemplos de aplica√ß√£o

::: box-dica3
- üè• Localiza√ß√£o de casos de uma doen√ßa notificados em uma cidade.
- üå≥ Distribui√ß√£o espacial de √°rvores em um parque urbano.
- üêæ Registros de avistamentos de animais silvestres em uma reserva.
- üî• Pontos de ocorr√™ncia de focos de inc√™ndio florestal detectados por sat√©lite.
:::

::: box-dica2
Neste tipo de dado, o evento aleat√≥rio de interesse √© a posi√ß√£o espacial onde o fen√¥meno ocorre, e n√£o uma vari√°vel medida em si. A an√°lise busca entender se os pontos seguem um padr√£o aleat√≥rio, agrupado (clusters) ou disperso no espa√ßo.

:::

```{r echo=F, fig.align="center", out.width= "55%", fig.show='hold'}
knitr::include_graphics('figuras/Cluster2.png')
```


```{r echo=F, fig.align="center", message=FALSE, warning=FALSE, comments=NA, out.width="70%", comment=NA}
knitr::include_graphics('figuras/pontos1.jpg')
```


## Estimativas de Kernel (ou Mapas de Calor)

As estimativas de densidade kernel s√£o uma t√©cnica amplamente utilizada para **representar visualmente a concentra√ß√£o espacial de eventos pontuais**, como casos de doen√ßas, crimes ou ocorr√™ncias de focos de calor. Essa abordagem transforma um conjunto de pontos em uma superf√≠cie cont√≠nua de intensidade, evidenciando √°reas com maior ou menor densidade (nesse caso a frequencia) de eventos.

```{r echo=FALSE, fig.align="center", out.width="60%", fig.cap="Localiza√ß√£o da ocorr√™ncia de casos de dengue em Belo Horizonte/MG"}
knitr::include_graphics('figuras/dengueBH.png')
```

A t√©cnica foi aplicada para identificar √°reas de maior risco de dengue em Belo Horizonte/MG. O mapa resultante revela zonas de alta concentra√ß√£o de casos, o que pode subsidiar a√ß√µes de controle vetorial e pol√≠ticas p√∫blicas de sa√∫de mais direcionadas.

O objetivo principal √© estimar a fun√ß√£o de intensidade espacial $\hat{\lambda}_{\tau}(u)$, que descreve a probabilidade de ocorr√™ncia de eventos em diferentes locais da regi√£o de estudo.


```{r echo=F, fig.align="center", out.width= "45%", fig.show='hold'}
knitr::include_graphics('figuras/kernel2.png')
```

* Estimador de intensidade de distribui√ß√£o de pontos: 

$$\hat{\lambda}_{\tau}(u) = \dfrac{1}{\tau^2}\sum k(\dfrac{d(u_i , u)}{\tau}) \text{   ,   } d(u_i , u) \leq \tau$$

Sabendo que:

- $\hat{\lambda}_{\tau}(u)$: estimativa da intensidade do processo pontual no ponto $u$.
    
- $\tau$: par√¢metro de suaviza√ß√£o (largura de banda), define o raio de influ√™ncia dos pontos ao redor de $u$.
    
- $u_i$: coordenadas dos pontos observados no plano (ex.: localiza√ß√£o dos eventos).
    
- $d(u_i, u)$: dist√¢ncia entre o ponto observado $u_i$ e o ponto de avalia√ß√£o $u$. Normalmente, a dist√¢ncia euclidiana.
    
- $k(\cdot)$: fun√ß√£o kernel que define o peso atribu√≠do a cada ponto com base na dist√¢ncia. Exemplos:
    
i) *Kernel gaussiano*: atribui maior peso aos pontos mais pr√≥ximos.
ii) *Kernel uniforme*: todos os pontos dentro do raio recebem o mesmo peso.
iii) *Kernel Epanechnikov*: pesos decrescem com a dist√¢ncia, chegando a zero na borda.

    
- Condi√ß√£o $d(u_i, u) \leq \tau$: garante que apenas os pontos dentro da vizinhan√ßa (de raio $\tau$) contribuam para a estimativa.
    
### Como funciona:

- Para cada ponto no espa√ßo, √© aplicado um funil de suaviza√ß√£o (kernel) que distribui "peso" ao redor do ponto, atribuindo maior peso √†s √°reas pr√≥ximas e menor peso conforme a dist√¢ncia aumenta.

- Ou seja, esse peso decresce com o aumento da dist√¢ncia a partir do centro, de acordo com uma fun√ß√£o $k(\cdot)$, e √© controlado por um par√¢metro chamado largura de banda ($\tau$).

- O resultado √© uma superf√≠cie cont√≠nua de densidade, onde regi√µes com cores mais quentes (vermelho, laranja) indicam maior concentra√ß√£o de eventos.

::: box-dica1

üåßÔ∏è Analogia intuitiva:

O kernel atua como um limpador de para-brisa, pesando mais os eventos pr√≥ximos e menos os eventos muito distantes. A escolha do tamanho do limpador ($\tau$) e do tipo de movimento (forma da fun√ß√£o kernel) define o quanto voc√™ v√™ ao redor do ponto onde est√° focando.
:::

```{r echo=F, fig.align="center", out.width= "50%", fig.show='hold'}
knitr::include_graphics('figuras/kernel3.png')
```

A figura acima mostra como diferentes larguras de banda ($500 m$, $1.500 m$ e $2.500 m$) alteram o grau de suaviza√ß√£o:

i) Largura pequena ($500 m$): permite detectar agrupamentos muito locais, mas pode introduzir ru√≠dos, ou seja, varia√ß√µes artificiais causadas por flutua√ß√µes aleat√≥rias nos dados, que n√£o representam padr√µes reais.

ii) Largura intermedi√°ria ($1.500 m$): equil√≠brio entre detalhe e suavidade.

Largura maior ($2.500 m$): suaviza padr√µes locais, ideal para visualizar tend√™ncias gerais.


[*Fonte: Refer√™ncia cient√≠fica: Druck, S.; Carvalho, M.S.; C√¢mara, G.; Monteiro, A.V.M. (eds) "An√°lise Espacial de Dados Geogr√°ficos". Bras√≠lia, EMBRAPA, 2004](http://www.dpi.inpe.br/gilberto/livro/analise/cap2-eventos.pdf)


# Geoestat√≠stica

* Dados usados em geoestat√≠stica s√£o atributos cont√≠nuos medidos em localiza√ß√µes fixas, na maioria das vezes amostrados no espa√ßo geogr√°fico, e que queremos analisar para entender como um fen√¥meno varia no espa√ßo.

## Estrutura dos dados geoestat√≠sticos

Imagine que voc√™ tem um conjunto de pontos no mapa, e para cada ponto voc√™ tem um valor observado. O conjunto de dados geralmente tem:

|   Latitude   |  Longitude   | Atributo Mensurado |
|:-----------:|:------------:|:----------------:|
|   -22.90    |   -43.20     |       5.4        |
|   -22.91    |   -43.22     |       6.1        |
|   -22.92    |   -43.18     |       5.9        |

## Exemplos de aplica√ß√£o

::: box-dica3
- üåßÔ∏è Medi√ß√£o da quantidade de chuva em diferentes locais de uma cidade.</li>
- ü¶ü Contagem de ovos de Aedes aegypti em ovitrampas.</li>
- üå´Ô∏è Concentra√ß√£o de poluentes no ar em pontos georreferenciados.</li>
- üåΩ An√°lise da produtividade agr√≠cola em diferentes talh√µes de uma fazenda.</li>

:::


* Umas das aplica√ß√µes mais importantes da geoestat√≠stica √© a interpola√ß√£o de dados, ou seja, estima√ß√£o de valores em locais onde n√£o h√° medi√ß√£o.


## Semivariograma: a base da an√°lise espacial

Uma das principais ferramentas da geoestat√≠stica √© o semivariograma, que mede o quanto dois pontos pr√≥ximos no espa√ßo se parecem (ou se diferem) com rela√ß√£o ao valor de uma vari√°vel.

::: box-dica2
**A ideia central √©**: Se dois pontos est√£o muito pr√≥ximos, √© esperado que seus valores sejam parecidos. J√° se estiverem distantes, a diferen√ßa entre os valores tende a aumentar.

:::

A vers√£o experimental do semivariograma √© calculada para diferentes dist√¢ncias entre os pontos, usando a seguinte f√≥rmula:

<!-- * A determina√ß√£o experimental do semivariograma, para cada valor de $x_i$, considera todos os pares de amostras $z(x)$ e $z(x+h)$, separadas pelo vetor dist√¢ncia $h$, a partir da equa√ß√£o:  -->

<!-- ```{r echo=F, fig.align="center", out.width= "25%", fig.show='hold'} -->
<!-- knitr::include_graphics('figuras/variograma3.png') -->
<!-- ``` -->


$$\hat{\gamma}(h) = \dfrac{1}{2N(h)}\sum^{N(h)}_{i=1}[z(x_i) - z(x_i + h)]^2 $$
 Sabendo que:
 
 - $\hat{\gamma}(h)$: valor estimado do fen√¥meno para a dist√¢ncia $h$;

- $N(h)$: n√∫mero de pares de pontos separados por uma dist√¢ncia $h$;

- $z(x_i)$: valor observado da vari√°vel na localiza√ß√£o $x_i$;

- $z(x_i + h)$: valor observado da vari√°vel em um ponto a uma dist√¢ncia $h$ de $x_i$.

* A express√£o representa a \textbf{diferen√ßa m√©dia ao quadrado} entre os valores da vari√°vel observada em pares de pontos separados pela dist√¢ncia $h$.



<!-- * Sendo $\hat{\gamma}(h)$ o semivariograma estimado e $N(h)$ o n√∫mero de pares de valores medidos, $z(x)$ e $z(x+h)$, separados pelo vetor $h$.   -->

```{r echo=F, fig.align="center", out.width= "40%", fig.show='hold'}
include_graphics('figuras/variograma1.png')
```

::: box-dica1

üìå **Efeito Pepita (C‚ÇÄ)**: √â a varia√ß√£o observada mesmo quando a dist√¢ncia entre os pontos √© muito pequena ou zero. Costuma representar erros de medi√ß√£o ou variabilidade microsc√≥pica n√£o capturada.

üìå **Patamar (C)**: √â o valor em que o variograma se estabiliza, indicando que a partir de certa dist√¢ncia, a variabilidade entre os pontos n√£o aumenta mais. Representa a vari√¢ncia total dos dados.

üìå **Alcance (a)**: √â a dist√¢ncia a partir da qual dois pontos deixam de estar correlacionados. At√© essa dist√¢ncia, os valores ainda apresentam semelhan√ßa espacial, ou seja, ap√≥s essa dist√¢ncia, tornam-se independentes.

:::

Apesar de √∫til, essa f√≥rmula n√£o √© robusta em todas as situa√ß√µes. Em alguns casos, a variabilidade n√£o √© constante ao longo da √°rea estudada ‚Äî o que chamamos de heterocedasticidade. Nesses cen√°rios, modelos diferentes podem ser utilizados para representar o comportamento do semivariograma. Por exemplo:

- Modelo Exponencial

- Modelo Esf√©rico

- Modelo Gaussiano




```{r echo=F, fig.align="center", out.width= "40%", fig.show='hold'}
include_graphics('figuras/variograma2.png')
```


* **Exemplo:** Mapa sobre o teor de argila no solo.

```{r echo=F, fig.align="center", out.width= "70%", fig.show='hold'}
knitr::include_graphics('figuras/geoestatistica7.png')
```

A imagem mostra a interpola√ß√£o do teor de argila em uma √°rea agr√≠cola da Fazenda Canchim (SP), a partir de amostras de solo coletadas em campo. Diversos m√©todos s√£o comparados: **a geoestat√≠stica (krigagem)**, que utiliza a estrutura de depend√™ncia espacial dos dados via semivariograma e produz um mapa suavizado e estatisticamente robusto; o m√©todo do **inverso da dist√¢ncia (IDW)**, que pondera os pontos mais pr√≥ximos com maior influ√™ncia, resultando em maior detalhamento local, mas com risco de exagerar varia√ß√µes; a **m√©dia simples**, que suaviza os dados sem considerar plenamente a variabilidade espacial; e o m√©todo do **vizinho mais pr√≥ximo**, que gera √°reas abruptas ao atribuir a cada regi√£o o valor da amostra mais pr√≥xima, sem suaviza√ß√£o. O exemplo evidencia como a escolha do m√©todo de interpola√ß√£o impacta diretamente a qualidade e continuidade do mapa final.



[*Fonte: Refer√™ncia cient√≠fica: Druck, S.; Carvalho, M.S.; C√¢mara, G.; Monteiro, A.V.M. (eds) "An√°lise Espacial de Dados Geogr√°ficos". Bras√≠lia, EMBRAPA, 2004](http://www.dpi.inpe.br/gilberto/livro/analise/cap3-superficies.pdf)

# Dados de √Årea

* Na an√°lise espacial por √°reas, o atributo de interesse costuma ser uma medida agregada (como contagem de casos, taxa de mortalidade, m√©dia de renda, etc.) calculada dentro de uma unidade geogr√°fica bem definidas (como bairros, munic√≠pios, setores censit√°rios ou regi√µes administrativas.)

* Essas √°reas s√£o representadas por pol√≠gonos, que podem ter formas irregulares e manter rela√ß√µes espaciais com as √°reas vizinhas, seja por fronteiras compartilhadas, conex√µes f√≠sicas (como estradas e rios), ou por semelhan√ßas em caracter√≠sticas socioecon√¥micas (como n√≠vel de renda ou acesso a servi√ßos).

::: box-dica2
O objetivo da an√°lise de dados de √°rea √© identificar, explicar e interpretar padr√µes espaciais e tend√™ncias que ocorrem entre essas unidades geogr√°ficas pr√©-definidas.

:::

## Exemplos de aplica√ß√£o

::: box-dica3

- ü¶ü Taxa de incid√™ncia de dengue por bairro em uma cidade.
- üí∏ Renda per capita por setor censit√°rio.
- üåΩ Produtividade agr√≠cola por microrregi√£o.
- üè´ Taxa de evas√£o escolar por munic√≠pio.
- üöî Taxa de criminalidade por distrito policial.
- üì¶ Volume de vendas por zona de entrega.
:::

## Mapa Tem√°tico

* O mapa tem√°tico tem como principal objetivo visualizar e analisar a distribui√ß√£o espacial de um fen√¥meno espec√≠fico.

* O mapa tem√°tico abaixo mostra a frequ√™ncia de artigos cient√≠ficos selecionados na revis√£o integrativa sobre diagn√≥stico microbiol√≥gico de Salmonella spp. na aquicultura entre 2000 e 2020 por pa√≠ses de diferentes continentes. Fonte: Porto et al. 2023 ([link](https://tede.ufrrj.br/jspui/bitstream/jspui/6673/2/2023%20-%20Yuri%20Duarte%20Porto%20%28parcialmente%20liberada%29.pdf)).

```{r echo=F, fig.align="center", out.width="70%"}
knitr::include_graphics('figuras/tese_yuri.png')
```


## Matriz de Vizinhan√ßa

- A **matriz de vizinhan√ßa** \( W \) √© uma matriz quadrada de dimens√£o \( n \times n \), onde cada elemento \( w_{ij} \) representa uma **medida de proximidade ou conectividade espacial** entre duas regi√µes \( O_i \) e \( O_j \).

- Essa matriz √© fundamental na an√°lise espacial, pois define **quais √°reas s√£o consideradas vizinhas** e como essa vizinhan√ßa influencia os fen√¥menos observados.

```{r echo=F, fig.align="center", out.width="80%"}
knitr::include_graphics('figuras/vizinhanca.png')
```

- A matriz \( W \) pode ser **bin√°ria** (0 ou 1) ou **ponderada**, dependendo do crit√©rio adotado.

::: box-dica4

üìå Crit√©rios comuns para definir vizinhan√ßa:

- \( w_{ij} = 1 \), se \( O_i \) **toca** \( O_j \) (ou seja, compartilham uma fronteira comum). Esse tamb√©m √© chamado de crit√©rio de **contiguidade**.

- \( w_{ij} = 1 \), se a **dist√¢ncia entre os centr√≥ides** das regi√µes \( O_i \) e \( O_j \) for **menor que um limite \( h \)**. Esse √© o crit√©rio baseado em **dist√¢ncia geogr√°fica**.

- \( w_{ij} = \frac{l_{ij}}{l_i} \), onde:

  - \( l_{ij} \): comprimento da fronteira compartilhada entre \( O_i \) e \( O_j \)
  
  - \( l_i \): per√≠metro total da regi√£o \( O_i \) 
  
  Esse crit√©rio expressa a **propor√ß√£o da fronteira** de \( O_i \) que est√° em contato com \( O_j \), e √© √∫til para an√°lises mais refinadas de conectividade.

:::



## Moran Global, Moran Local e Lisa Map

### üßÆ Moran Global

* Mede a autocorrela√ß√£o espacial global, ou seja, se valores semelhantes est√£o agrupados no espa√ßo.


$$I = \frac{ \sum_{i=1}^{n} \sum_{j=1}^{n} w_{ij} (y_i - \bar{y})(y_j - \bar{y}) }{ \sum_{i=1}^{n} (y_i - \bar{y})^2 }$$

::: box-dica4

* $I > 0$: valores similares est√£o pr√≥ximos (agrupamento positivo).

* $I < 0$: valores diferentes est√£o pr√≥ximos (dispers√£o).

* $I \approx 0$: padr√£o aleat√≥rio.

:::

Sabendo que:

- \( I \): valor do √≠ndice de Moran global.
- \( n \): n√∫mero total de unidades espaciais (regi√µes).
- \( y_i \): valor da vari√°vel de interesse na regi√£o \( i \).
- \( \bar{y} \): m√©dia dos valores de \( y \) em todas as regi√µes.
- \( w_{ij} \): elemento da matriz de vizinhan√ßa que representa a rela√ß√£o espacial entre as regi√µes \( i \) e \( j \).
  - \( w_{ij} = 1 \) se \( i \) e \( j \) s√£o vizinhos, 0 caso contr√°rio (ou ponderado).
- O numerador mede a covari√¢ncia espacial ponderada, e o denominador √© a vari√¢ncia total de \( y \).

### üßÆ Moran Local (LISA)

* Avalia a autocorrela√ß√£o espacial **local**, permitindo identificar regi√µes com agrupamentos (clusters) ou comportamentos at√≠picos.

$$I^{(i)} = \frac{n}{\sum_{j=1}^{n} (z_j - \bar{z})^2} \sum_{j=1}^{n} w_{ij} (z_i - \bar{z})(z_j - \bar{z})$$

Sabendo que:

- \( I^{(i)} \): √≠ndice de Moran local para a regi√£o \( i \).
- \( n \): n√∫mero total de regi√µes.
- \( z_i \): valor padronizado (ou original, dependendo da conven√ß√£o) da vari√°vel na regi√£o \( i \).
- \( \bar{z} \): m√©dia da vari√°vel \( z \).
- \( w_{ij} \): peso espacial entre as regi√µes \( i \) e \( j \).
- A soma considera a influ√™ncia dos vizinhos \( j \) sobre o ponto \( i \), ponderada pela matriz de vizinhan√ßa.

::: box-dica2

üó∫Ô∏è Resumindo

- **Moran Global** indica se h√° padr√£o geral de autocorrela√ß√£o espacial (positivo, negativo ou aleat√≥rio).

- **Moran Local** revela **onde** esses padr√µes ocorrem: clusters de alto/alto (*hotspots*), baixo/baixo (*coldspots*), alto/baixo (*outliers*), etc.

:::
<!-- ```{r echo=F, fig.align="center", out.width="20%", fig.cap="Moran Global"} -->
<!-- knitr::include_graphics('figuras/moran_global.png') -->
<!-- ``` -->

<!-- ```{r echo=F, fig.align="center", out.width="30%", fig.cap="Moran Local"} -->
<!-- knitr::include_graphics('figuras/moran_local.png') -->
<!-- ``` -->


### üó∫Ô∏è LISA Map

O LISA Map √© um mapa tem√°tico que representa graficamente os resultados do √çndice de Moran Local. Ele identifica:

- Clustering local (agrupamento de valores semelhantes)

- Outliers espaciais (valores discrepantes em rela√ß√£o aos vizinhos)

- Regi√µes n√£o significativas (sem padr√£o espacial detect√°vel)


| Tipo de Associa√ß√£o        | Descri√ß√£o                                                | Interpreta√ß√£o Espacial                                                |
| ------------------------- | -------------------------------------------------------- | --------------------------------------------------------------------- |
| üî¥ **Alto-Alto (High-High)** | Valor alto cercado por vizinhos tamb√©m com valores altos | Indica **cluster de altas magnitudes**, tamb√©m chamado de **hotspot** |
| üîµ **Baixo-Baixo (Low-Low)** | Valor baixo cercado por vizinhos com valores baixos      | Indica **cluster de baixas magnitudes**, ou **coldspot**              |
| üü† **Alto-Baixo (High-Low)** | Valor alto cercado por valores baixos                    | Indica um **outlier espacial positivo**                               |
| üü° **Baixo-Alto (Low-High)** | Valor baixo cercado por valores altos                    | Indica um **outlier espacial negativo**                               |
| ‚ö™ **N√£o significativo**     | Sem associa√ß√£o espacial relevante                        | O valor na regi√£o n√£o apresenta padr√£o espacial detect√°vel            |


Os valores do Moran Local s√£o testados por permuta√ß√£o para verificar se o padr√£o observado √© estatisticamente significativo ou poderia ocorrer por acaso.

Apenas as regi√µes significativas (p-valor < 0.05) costumam ser coloridas nos mapas.

<!-- * Desigualdade no n√≠vel distrital na cobertura de sa√∫de reprodutiva, materna, neonatal e infantil na √çndia -->

<!-- ```{r echo=F, fig.align="center", out.width="90%"} -->
<!-- knitr::include_graphics('figuras/moran_local2.png') -->
<!-- ``` -->

<!-- [Fonte: PANDA, Basant Kumar; KUMAR, Gulshan; AWASTHI, Ashish. District level inequality in reproductive, maternal, neonatal and child health coverage in India. BMC public health, v. 20, n. 1, p. 1-10, 2020.](https://bmcpublichealth.biomedcentral.com/articles/10.1186/s12889-020-8151-9) -->

Esse mapa abaixo pertence ao artigo ["Are regions equal in adversity? A spatial analysis of the spread and dynamics of COVID-19 in Europe", de Amdaoud, Arcuri e Levratto (2021)](https://www.researchgate.net/publication/349729379_Are_regions_equal_in_adversity_A_spatial_analysis_of_the_spread_and_dynamics_of_COVID-19_in_Europe). O artigo realiza uma an√°lise espacial detalhada da mortalidade por COVID-19 em 125 regi√µes europeias durante a primeira onda da pandemia (mar√ßo a maio de 2020). 

```{r echo=F, fig.align="center", out.width="80%"}
knitr::include_graphics('figuras/lisa_map_covid.png')
```

Utilizando o √≠ndice de Moran Local (LISA), o estudo identifica padr√µes de autocorrela√ß√£o espacial na mortalidade por COVID-19 entre as regi√µes europeias durante a primeira onda da pandemia. O resultado evidencia clusters espaciais significativos, com destaque para regi√µes High-High (altas taxas de mortalidade cercadas por outras com altas taxas), como o norte da It√°lia, Madrid e a regi√£o da Als√°cia, na Fran√ßa. Ao mesmo tempo, regi√µes Low-Low, como o sul da It√°lia, Dinamarca e partes da Alemanha Oriental, apresentaram baixa mortalidade em vizinhan√ßa igualmente baixa. Esses padr√µes persistentes ao longo do tempo indicam que a dissemina√ß√£o da pandemia seguiu l√≥gicas regionais, refor√ßando a import√¢ncia de pol√≠ticas p√∫blicas que considerem as desigualdades territoriais na resposta √† crise sanit√°ria.

## Modelos de Regress√£o Espacial

### Introdu√ß√£o
Al√©m das an√°lises explorat√≥rias para os dados espaciais de √°rea, √© poss√≠vel avan√ßar na modelagem estat√≠stica dos dados por meio de modelos espaciais que consideram a depend√™ncia espacial dos dados. Entre os mais utilizados est√£o os modelos de autocorrela√ß√£o espacial global, como o **SAR (Simultaneous Autoregressive Model)** e o **CAR (Conditional Autoregressive Model)** (CRESSIE, 1993). O modelo SAR incorpora a depend√™ncia espacial diretamente no valor da vari√°vel dependente, assumindo que o valor observado em uma regi√£o √© influenciado pelos valores das regi√µes vizinhas. J√° o modelo CAR considera essa depend√™ncia na estrutura do erro, sendo muito utilizado em abordagens bayesianas para modelagem de risco em √°reas geogr√°ficas.

Outra abordagem √© a dos modelos com efeitos espaciais locais, como a **Regress√£o Geograficamente Ponderada (GWR)** (FOTHERINGHAM et al., 2002). Diferente dos modelos SAR e CAR, que assumem rela√ß√µes espaciais globais, o GWR permite que os coeficientes da regress√£o variem ao longo do espa√ßo, ajustando uma equa√ß√£o espec√≠fica para cada localidade. Isso possibilita identificar como os efeitos de uma vari√°vel explicativa sobre a resposta mudam de acordo com a localiza√ß√£o, sendo especialmente √∫til em contextos onde h√° forte heterogeneidade espacial. 

### Na pr√°tica

* `r colFmt(" Hip√≥tese de independ√™ncia das observa√ß√µes em geral √© Falsa ",'orange')` $\rightarrow$  Existe depend√™ncia espacial, ou seja, o valor observado em uma localiza√ß√£o tende a se parecer com os valores observados em locais vizinhos.

* Efeitos Espaciais $\rightarrow$ Se existir depend√™ncia ou correla√ß√£o espacial significativa, devemos incluir no modelo os `r colFmt(" Efeitos Espaciais ",'darkpurple')`, caso contr√°rio, as estimativas geradas pelo modelo de regress√£o podem ficar enviesadas, criando associa√ß√µes esp√∫rias (isto √©, sugerindo rela√ß√µes estat√≠sticas onde elas n√£o existem de fato, ou mascarando rela√ß√µes reais);

* `r colFmt("**Como verificar ?** ",'darkred')` $\rightarrow$ Para detectar a depend√™ncia espacial, podemos analisar os res√≠duos da regress√£o tradicional (OLS), utilizando indicadores como o √≠ndice de Moran dos res√≠duos. Se os res√≠duos mostrarem autocorrela√ß√£o espacial significativa, isso indica que h√° estrutura espacial n√£o modelada.

* `r colFmt("**Detectada a autocorrela√ß√£o espacial: e agora ?** ",'darkblue')` $\rightarrow$  √â necess√°rio adotar modelos de regress√£o que incorporem explicitamente os efeitos espaciais, evitando vieses nas estimativas dos coeficientes.


### i) Modelos Globais: 

* Esses modelos assumem que a estrutura espacial √© constante em todo o espa√ßo geogr√°fico. Utilizam um √∫nico par√¢metro para captar a autocorrela√ß√£o.

* Um exemplo √© o **Modelo de Erro Espacial** (*Spatial Error Model* - **CAR**), representado por:
    
$$y_i = \beta_0 + \sum^{p}_{k} \beta_k x_{ik}  + \varepsilon_i \text{    , sendo  }  \varepsilon_i = \lambda  W + \xi$$

::: box-dica4
Sendo:

- $y_i$: valor observado da vari√°vel dependente na unidade $i$;

- $\beta_0$: intercepto da regress√£o;

- $\beta_k$: coeficiente da $k$-√©sima vari√°vel explicativa;

- $x_{ik}$: valor da $k$-√©sima vari√°vel explicativa para a unidade $i$;

- $\varepsilon_i$: erro com estrutura de autocorrela√ß√£o espacial;


- $\lambda$: coeficiente de autocorrela√ß√£o espacial;

- $W$: matriz de vizinhan√ßa espacial (define como cada unidade est√° conectada √†s outras);

- $\xi$: erro aleat√≥rio normal (sem autocorrela√ß√£o), com $\mathbb{E}[\xi]()
:::

$\rightarrow$ Podemos observar que os efeitos da autocorrela√ß√£o espacial s√£o associados ao termo de erro.

::: box-dica2

üß† Interpreta√ß√£o:

- Se $\lambda \ne 0$, h√° evid√™ncia de depend√™ncia espacial nos erros, ou seja, o erro em uma localidade est√° correlacionado com os erros em localidades vizinhas.

- Se $\lambda = 0$, o modelo reduz-se a uma regress√£o tradicional, e n√£o h√° autocorrela√ß√£o espacial significativa.
:::



### ii) Modelos Locais: 

* Enquanto os modelos globais assumem uma rela√ß√£o espacial uniforme, os modelos locais admitem que os par√¢metros da regress√£o variam ao longo do espa√ßo geogr√°fico.

* Um exemplo cl√°ssico √© o Modelo **Geograficamente Ponderado** (*Geographically Weighted Regression* - **GWR**), expresso por:
  
    
<!-- $$y_i = \beta_{0}(u_i, v_i) + \sum^{p}_{k}  \beta_k (u_i, v_i) x_{ik} + \varepsilon_i \text{    , sendo  } (u_i, v_i) \text{    as coordenadas geogr√°ficas}$$ -->

<!-- Onde: -->

<!-- - $(u_i, v_i)$ representam as \textbf{coordenadas geogr√°ficas} da observa√ß√£o $i$; -->
<!-- - Os coeficientes $\beta_k(u_i, v_i)$ s√£o estimados \textbf{localmente}, variando de acordo com a posi√ß√£o no espa√ßo. -->


\[
y_i = \beta_{0}(u_i, v_i) + \sum_{k=1}^{p} \beta_k(u_i, v_i) \cdot x_{ik} + \varepsilon_i,
\\
\quad \text{com } \beta_k(u_i, v_i) \text{ estimado via } 
\sum_{j=1}^{n} K(d_{ij}) \cdot x_{jk}
\]

::: box-dica4

Onde:

- $(u_i, v_i)$: coordenadas geogr√°ficas da observa√ß√£o $i$;

- $\beta_k(u_i, v_i)$: coeficiente local da vari√°vel explicativa $x_k$, estimado para a posi√ß√£o $i$;

- $K(d_{ij})$: fun√ß√£o kernel que atribui um peso √† observa√ß√£o $j$ com base na dist√¢ncia $d_{ij}$ entre as localiza√ß√µes $i$ e $j$;
:::


**Efeito da vizinhan√ßa no GWR**: No GWR, para estimar os coeficientes de regress√£o em cada local, utiliza-se um "kernel espacial". O objetivo do kernel √© dar mais peso para observa√ß√µes pr√≥ximas e menos peso para as distantes. A forma e o alcance desse kernel s√£o definidos por um par√¢metro chamado largura de banda (*bandwidth*).

```{r echo=F, fig.align="center", out.width= "80%", fig.show='hold'}
knitr::include_graphics('figuras/largura_banda_gwr.png')
```

$\rightarrow$ Quanto menor $d_{ij}$, maior √© o peso de $j$ na estima√ß√£o de $\beta_k(u_i, v_i)$.

[Fonte: ARDILLY, Pascal et al. Manuel d‚Äôanalyse spatiale. 2018.](https://ec.europa.eu/eurostat/documents/3859598/9462709/INSEE-ESTAT-SPATIAL-ANA-18-EN.pdf)



<!-- ## Como trabalhar com An√°lise Estat√≠stica Espacial: Algumas ferramentas -->

<!-- ### SiG QGIS -->

<!-- ```{r echo=F, fig.align="center", out.width="80%"} -->
<!-- knitr::include_graphics('figuras/QGIS.png') -->
<!-- ``` -->

<!-- [QGIS: Um Sistema de Informa√ß√£o Geogr√°fica livre e aberto](https://www.qgis.org/pt_BR/site/) -->

<!-- ### GEODA -->

<!-- ```{r echo=F, fig.align="center", out.width="80%"} -->
<!-- knitr::include_graphics('figuras/GEODA.png') -->
<!-- ``` -->

<!-- [GEODA: AN INTRODUCTION TO SPATIAL DATA ANALYSIS](https://spatial.uchicago.edu/geoda) -->


<!-- ### R -->

<!-- ```{r echo=F, fig.align="center", out.width="60%"} -->
<!-- knitr::include_graphics('figuras/logo_ubuntu.png') -->
<!-- ``` -->

<!-- Fonte: [Dicas para integra√ß√£o e instala√ß√£o do R 4.2 no Ubuntu 22.04 LTS e os pacotes espaciais](https://rtask.thinkr.fr/installation-of-r-4-2-on-ubuntu-22-04-lts-and-tips-for-spatial-packages/) -->


<!-- ### Python -->

<!-- ```{r echo=F, fig.align="center", out.width="60%"} -->
<!-- knitr::include_graphics('figuras/geopandas.png') -->
<!-- ``` -->

<!-- Fonte: [Github Geopandas](https://geopandas.org/en/stable/) -->

<!-- # Ser√£o feitas cinco aplica√ß√µes da Estat√≠stica Espacial utiliza√ß√£o o pacote estat√≠stico R: -->

<!-- [Clique aqui para baixar os dados das aplica√ß√µes](https://drive.google.com/drive/folders/10WMJYlwHcEX9zw3_RUjDQz5DGZByiI2N?usp=sharing) -->

# **Aplica√ß√£o I:** Utilizando a biblioteca *tmap* para constru√ß√£o r√°pida de mapas tem√°ticos

```{r, echo=T, out.width='90%'}
library(tmap)

# Carrega dados espaciais do mundo com vari√°veis socioecon√¥micas
data(World)

# Define o estilo do mapa (opcional, apenas visual)
tmap_style("classic")

# Cria um mapa tem√°tico utilizando a vari√°vel esperan√ßa de vida
qtm(World, fill = "life_exp", 
    title = "Esperan√ßa de Vida por Pa√≠s",
    fill.title = "Anos",
    borders = "gray40")

```

<!-- ## Exerc√≠cio proposto: -->

<!-- Altere o script para representar outra vari√°vel (por exemplo, taxa de alfabetiza√ß√£o, popula√ß√£o, ou √°rea). O que muda na interpreta√ß√£o do mapa ? Quais pa√≠ses se destacam em cada caso ? -->


# **Aplica√ß√£o II:** Baixando e construindo mapas a partir da biblioteca *geobr*

### Bibliotecas que ser√£o utilizadas:

```{r, echo=T}
library(ggplot2)
library(dplyr)
library(viridis)
library(geobr)
library(sf)
library(maptools)
library(leaflet)
library(ggspatial)

```

Para acessar os dados dos limites territoriais de todos os estados brasileiros √© necess√°rio utilizar a fun√ß√£o *read_state*.

```{r, echo=T}
brasil.ufs <- read_state(code_state = "all", year=2019, showProgress = FALSE)
```

### Primeiro, vamos fazer um gr√°fico apenas com as geometrias.

```{r, echo=T}
ggplot(brasil.ufs) + 
  geom_sf()
```

Para a constru√ß√£o de um mapa onde cada estado recebe uma cor de acordo com a sua regi√£o geogr√°tica, procedemos da seguinte forma: 
  
```{r, echo=T,  out.width="90%"}
ggplot(brasil.ufs) + 
  geom_sf(aes(fill = name_region)) + 
  labs(fill="Regi√£o")
```

Para plotar o mapa, agora utilizaremos dados relativos ao acesso √† rede de esgoto de acordo com a unidade da federa√ß√£o ([fonte dos dados](https://pt.wikipedia.org/wiki/Lista_de_unidades_federativas_do_Brasil_por_acesso_%C3%A0_rede_de_esgoto) ) segundo o censo de 2022. Vamos associar esses dados a tabela de acordo com a vari√°vel State e padronizaremos a porcentagem para variar de 0 a 100.


```{r, echo=T,  out.width="90%"}
# Entrando com os dados observados na wikipedia
acesso_esgoto <- data.frame(
  sigla = c("SP", "DF", "RJ", "MG", "ES",
            "PR", "RS", "PE", "GO", "SC",
            "BA", "MS", "RR", "CE", "SE",
            "PB", "AC", "AM", "AL", "TO",
            "MT", "RN", "PI", "PA", "RO",
            "AP", "MA"),
  
  rede_esgoto = c(93.6, 89.9, 88.9, 81.4, 78.2,
                  73.7, 71.0, 65.1, 61.7, 61.4,
                  59.5, 57.2, 56.0, 52.8, 51.0,
                  49.9, 47.7, 47.0, 40.6, 39.8,
                  37.4, 35.8, 26.8, 23.5, 21.7,
                  20.7, 18.1)
)

```



```{r, echo=T,  out.width="90%"}
# Unindo os dados com o shapefile

brasil.ufs <- brasil.ufs %>%
  left_join(acesso_esgoto, by = c("abbrev_state" = "sigla"))


```

<center>

  
```{r, echo=T,  out.width="90%"}
# Construindo o mapa com ggplot
brasil.ufs |>
  ggplot(aes(fill = rede_esgoto), color = "black") + 
  geom_sf() + 
  scale_fill_viridis(name = "Munic√≠pios com rede de esgoto (%)", direction = -1) + 
  xlab("Longitude") + ylab("Latitude") + annotation_scale(location = "bl") +
  annotation_north_arrow(location = "br") + 
  theme_minimal()
```

</center>
  
Uma forma alteranativa de apresentar esses mesmos dados se d√° pela apresenta√ß√£o de c√≠rculos com raios proporcionais a porcentgem de munic√≠pios com rede de esgoto no centroide de cada geometria (nesse caso, UF).

```{r, echo=T,  out.width="80%"}
# Calcula o centroide de cada estado no objeto espacial brasil.ufs.
coord_pontos <- brasil.ufs |>  
  st_centroid()
```

<center>

 
```{r, echo=T,  out.width="90%"}
# Construindo o mapa com ggplot
ggplot(brasil.ufs) + 
  geom_sf() + 
  geom_sf(data = coord_pontos, aes(size = rede_esgoto), col = "blue", 
          alpha = .65, show.legend = "point") +
    scale_size_continuous(name = "Munic√≠pios com rede de esgoto (%)") + 
    xlab("Longitude") + 
    ylab("Latitude") +
    annotation_scale(location = "bl") +
    annotation_north_arrow(location = "br") +
  theme_minimal()
```


</center>


Uma alternativa interativa para trabalhar com mapas √© com a utiliza√ß√£o do pacote *leaflet*
  
<center>

```{r, echo=T,  out.width="70%"}
leaflet(coord_pontos) |>
  # Camada tradicional com nomes e divis√µes pol√≠ticas
  addProviderTiles(providers$OpenStreetMap, group = "Mapa Pol√≠tico") |>
  # Camada de imagem de sat√©lite
  addProviderTiles(providers$Esri.WorldImagery, group = "Sat√©lite") |>
  # Adiciona os c√≠rculos nos centroides
  addCircleMarkers(
    label = ~ paste0(abbrev_state, ": ", rede_esgoto, "%"), # R√≥tulo exibido ao passar o mouse
    labelOptions = labelOptions(textsize = "13px"), # Tamanho da fonte do r√≥tulo
    radius = ~ rede_esgoto / 10,              # Raio do c√≠rculo proporcional
    fillOpacity = 0.5,                       # Transpar√™ncia dos c√≠rculos
    group = "Dados"
  ) |>
  # Adiciona controle para alternar entre as camadas de fundo
  addLayersControl(
    baseGroups = c("Mapa Pol√≠tico", "Sat√©lite"),
    overlayGroups = "Dados",
    options = layersControlOptions(collapsed = FALSE)
  )

```  
  
</center>
  
---

# **Aplica√ß√£o III:** Dengue em Dourados/MS - Parte 1: An√°lise explorat√≥ria

* Nesta apresenta√ß√£o, ser√£o utilizados dados com ru√≠do espacial, com o objetivo de preservar a confidencialidade das informa√ß√µes originais. Esses dados fazem parte da disserta√ß√£o de [Isis Rodrigues Reitman](https://sucupira.capes.gov.br/sucupira/public/consultas/coleta/trabalhoConclusao/viewTrabalhoConclusao.jsf?popup=true&id_trabalho=3666174), intitulada *‚ÄúSa√∫de e Ambiente Urbano: a rela√ß√£o de incid√™ncia de dengue e as disparidades espaciais em Dourados ‚Äì MS‚Äù*, apresentada em abril de 2016 no [Programa de P√≥s-Gradua√ß√£o em Geografia da Universidade Federal da Grande Dourados (UFGD)](https://portal.ufgd.edu.br/pos-graduacao/mestrado-doutorado-geografia/index).

* Os ru√≠dos nas coordenadas foram gerados a partir de uma distribui√ß√£o uniforme. A fun√ß√£o produz valores aleat√≥rios entre -15 e 15 para cada linha do conjunto de dados. Esse procedimento simula um deslocamento m√°ximo de at√© 15 metros em cada dire√ß√£o, o que √© suficiente para preservar o padr√£o espacial geral dos casos, ao mesmo tempo em que evita a identifica√ß√£o precisa das localiza√ß√µes originais.

```{r, eval=FALSE, echo = TRUE}
# Supondo que seu dataframe se chame `casos`
# Adicionando um ru√≠do aleat√≥rio pequeno (por exemplo, at√© ¬±15 metros) √†s coordenadas X e Y

set.seed(123)  # Para reprodutibilidade
casos$X_ruido <- casos$X + runif(nrow(casos), -15, 15)
casos$Y_ruido <- casos$Y + runif(nrow(casos), -15, 15)
```


* Essa aplica√ß√£o tamb√©m se encontra no [Curso de Estudos Ecol√≥gicos](https://ogcruz.github.io/) ministrado para o curso de [P√≥s-Gradua√ß√£o em Epidemiologia em Sa√∫de P√∫blica](http://ensino.ensp.fiocruz.br/cursos/mestrado-e-doutorado/epidemiologia-em-saude-publica) em 2019, pelos pesquisadores [Oswaldo Gon√ßalves Cruz (PROCC/FIOCRUZ)](https://lsbastos.github.io/PROCC/membro-9530671289607786.html) e [Wagner Tassinari (DEMAT/ICE/UFRRJ)](https://institucional.ufrrj.br/ruralpesquisa/wagner-de-souza-tassinari/)

 **OBS:** Os dados e as malhas geogr√°ficas utilizadas nessa apresenta√ß√£o, est√£o dispon√≠veis no seguinte endere√ßo: ([link](https://github.com/wtassinari/Estatistica_Espacial/tree/main/dados))


### Biliotecas do R que ser√£o utilizadas

```{r, echo=T}

library(readr)
library(tidyverse)
library(sf)
library(maptools)
library(spatstat)
library(tmap)
```

#### Lendo a tabela da popula√ß√£o por setor censit√°rio e os *shapes files* do contorno e por setor censit√°rio de Dourados/MS

```{r, echo=T}

pop2010 <- read_csv('dados/dengue_dourados/pop2010.csv')
setor.sf <- read_sf('dados/dengue_dourados/Setor_UTM_SIRGAS.shp', crs = 31981)
contorno.sf <- read_sf('dados/dengue_dourados/contorno.shp', crs = 31981)

```

üìå O que √© CRS (Coordinate Reference System) ?

O CRS √© como uma ‚Äúregra de tradu√ß√£o‚Äù entre o que est√° em um mapa e o mundo real. Ele define como as coordenadas (como 140, 12) se relacionam com locais verdadeiros na Terra, dizendo se os valores est√£o em metros, graus ou outra unidade, e onde fica o ponto de partida (a origem). Sem um CRS, uma coordenada n√£o tem significado, pois n√£o sabemos onde ela realmente est√° nem em que escala.

üó∫Ô∏è Por que isso √© importante ?

Se dois mapas tiverem CRSs diferentes, os pontos n√£o v√£o se alinhar corretamente ‚Äî como tentar juntar pe√ßas de quebra-cabe√ßa de caixas diferentes. Usar o CRS certo garante que todas as informa√ß√µes espaciais estejam bem posicionadas e coerentes. Por exemplo, o WGS 84 √© usado por GPS e Google Maps (em graus), enquanto o UTM √© usado para mapas locais mais precisos (em metros). Saber isso evita erros em an√°lises espaciais e garante que os dados ‚Äúconversem‚Äù entre si.

**OBS:** Se quiser saber um pouco mais a respeito do CRS, basta acessar ([link](https://rspatial.org/raster/spatial/6-crs.html))


### Fazendo um join com as tabelas com os setores censit√°rios + popula√ß√£o

```{r, echo=T}
setor.sf <- setor.sf |> mutate (idsetor = as.numeric(CD_GEOCODI)) |> inner_join(pop2010, by='idsetor')
```

### Lendo e plotando os casos de dengue georreferenciados em Dourados/MS

```{r, echo=T}
casos <- read_csv('dados/dengue_dourados/dengue_dourados.csv')
casos.sf <- st_as_sf(casos, coords = c("X", "Y"), crs = 31981) 
```

```{r, echo=T, out.width="60%"}
ggplot(setor.sf) + 
  geom_sf(fill = 'white', color='black') +
  geom_sf(data=casos.sf, color='red',size=1) +
  theme_void()
```

### Lendo e plotando os os pontos de coleta de lixo georreferenciados em Dourados/MS

```{r, echo=T}
lixo <- read_csv2('dados/dengue_dourados/lixo_dourados.csv')
lixo.sf <- st_as_sf(lixo, coords = c("X", "Y"), crs = 31981)
```

```{r, echo=T,  out.width="70%"}
ggplot(setor.sf) + 
  geom_sf(fill = 'white', color = 'black') +
  geom_sf(data=lixo.sf,color='blue',size=1) +
  theme_void()
```

* Como podemos observar, existem alguns pontos de coleta de lixo fora do contorno de Dourados/MS

### Uma forma de ficarmos s√≥ com os pontos dentro do pol√≠gono √© utilizando o comando `st_intersection`.


```{r, echo=T}
lixo2.sf <- st_intersection(contorno.sf, lixo.sf)
```

```{r, echo=T,  out.width="70%"}
ggplot(setor.sf) + 
  geom_sf(fill = 'white', color = 'black') +
  geom_sf(data=lixo2.sf,color='blue',size=1) +
  theme_void()
```

### Utilizando as informa√ß√µes dos casos (pontos) + do lixo (ponto) + popula√ß√£o de cada setor censit√°rio (mapa tem√°tico)

```{r, echo=T,  out.width="70%"}
# Adiciona categorias para legenda
lixo$tipo <- "Lixo"
casos.sf$tipo <- "Caso"

ggplot(setor.sf) + 
  geom_sf(aes(fill=pop)) + 
  geom_sf(data = casos.sf, color='red',size = 0.7, aes(colour = "Caso"), 
          show.legend = "point") +
  geom_sf(data = lixo2.sf, color = 'salmon', size = 1, aes(colour = "Lixo"), 
          show.legend = "point") +
  scale_fill_distiller(palette = "PuBu", direction = 1) +
  scale_colour_manual(values = c("Caso" = "red", "Lixo" = "salmon")) +
  theme_minimal()
```
### Construindo os buffers

* Ser√£o constru√≠dos buffers com raio de 500 metros ao redor de cada ponto de coleta de lixo. Essa abordagem permite analisar se os casos de dengue ocorrem dentro desse per√≠metro, ou seja, a at√© 500 metros dos pontos de coleta. O objetivo √© investigar se existe uma rela√ß√£o entre a proximidade desses locais e a ocorr√™ncia de casos de dengue.

**Buffers:** S√£o pol√≠gonos que contornam um objeto a uma determinada dist√¢ncia. Sua principal fun√ß√£o √© materializar os conceitos de ‚Äúperto‚Äù e ‚Äúlonge‚Äù.

```{r, echo=T,  out.width="70%"}
lixo_buffer <- st_buffer(lixo2.sf, 500) 

# Adiciona categorias para legenda
lixo_buffer$tipo <- "Lixo"
casos.sf$tipo <- "Caso"

ggplot(setor.sf) + 
  geom_sf(aes(fill = pop)) + 
  geom_sf(data = lixo_buffer, aes(color = tipo), fill = "transparent", size = 0.4) +
  geom_sf(data = casos.sf, aes(color = tipo), size = 0.7) +
  scale_fill_distiller(palette = "PuBu", direction = 1) +
  scale_color_manual(values = c("Caso" = "red", "Lixo" = "gray")) +
  theme_minimal()

```

### Representando os casos e o lixo de forma interativa com o a biblioteca `tmap`

```{r, echo=T,  out.width="90%"}
library(tmap)


tmap_mode("view") # modo interativo (Leaflet)
# tmap_mode("plot") # modo est√°tico (p/ publica√ß√£o)

# Constr√≥i o mapa
tm_shape(setor.sf) + tm_borders("black") +
  tm_shape(casos.sf) + tm_dots(col = "red", palette = "red") +
  tm_shape(lixo.sf) + tm_dots(col = "green", palette = "green") +
  tm_shape(lixo_buffer) + tm_borders(col = "blue")

```

### Convertendo o dado de pontos (padr√£o pontual) para dados de √°rea

```{r, echo=T}
library(sf)
library(dplyr)

# Conta casos confirmados (CLASSI_FIN == 1) por setor
casos <- casos.sf |>
  filter(CLASSI_FIN == 1) |>        # Filtra apenas casos confirmados
  mutate(contador = 1) |>          # Adiciona coluna de contagem
  st_join(setor.sf, join = st_within) |>  # Une os casos aos setores (dentro do pol√≠gono)
  group_by(ID) |>                 # Agrupa por ID do setor
  summarise(casos = sum(contador, na.rm = TRUE)) |> # Conta casos por setor
  st_drop_geometry()  ## remove atributos de geometria


# N√∫mero de dep√≥sitos de lixo por setor (sem geometria)
lixo <- lixo.sf |>
  mutate(contador = 1) |>                      # Adiciona coluna de contagem
  st_join(setor.sf, join = st_within) |>       # Junta pontos aos setores onde est√£o contidos
  group_by(ID) |>                              # Agrupa por setor
  summarise(lixo = sum(contador, na.rm = TRUE)) |>  # Soma os dep√≥sitos por setor
  st_drop_geometry()                           # Remove geometria


# Inserindo as contagens de lixo e casos confirmados na geometria dos setores
setor.sf <- setor.sf |>
  left_join(lixo, by = "ID") |>    # Junta a contagem de dep√≥sitos de lixo por setor
  left_join(casos, by = "ID")      # Junta a contagem de casos confirmados por setor

```


### Plotando o mapa tem√°tico dos casos por setor censit√°rio

```{r, echo=T,  out.width="70%"}
plot(setor.sf['casos'])
```

### Plotando o mapa tem√°tico dos pontos de coleta de lixo por setor censit√°rio

```{r, echo=T,  out.width="70%"}
plot(setor.sf['lixo'])
```

### Calculando a taxa de incid√™ncia e plotando o mapa tem√°tico dos pontos de coleta de lixo por setor censit√°rio

```{r, echo=T,  out.width="70%"}
setor.sf$tx <- (setor.sf$casos/setor.sf$pop) * 1000
setor.sf$tx[is.na(setor.sf$tx)] <- 0 # Transformando os missings em zero

summary(setor.sf$tx)
```

### Plotando a distribui√ß√£o da incid√™ncia em Dourados/MS

```{r, echo=T,  out.width="70%"}
library(wesanderson)
pal <- wes_palette("Moonrise3", 20, type = "continuous")

ggplot(setor.sf) + 
  geom_sf(aes(fill = tx), color = 'black') +
  scale_fill_gradientn(colours = pal) +
  ggtitle("Taxa de incid√™ncia de Dengue") + 
  theme_void()
```

### Kernel por atributos

- Vamos plotar o kernel por atributos referente a taxa de incid√™ncia de dengue em Dourados/MS.

- Primeiramente √© necess√°rio dissolver os pol√≠gonos em formato sf para obter o contorno. Nesse caso queremos preservar o atributo AREA

```{r, echo=T,  out.width="70%"}
dourados.contorno <- st_union(setor.sf)
plot(dourados.contorno)
```
- Agora iremos converter o contorno geogr√°fico da cidade de Dourados (um pol√≠gono `sf`) para o formato `owin `da classe `spatstat`, que √© usado para an√°lise espacial de padr√µes de pontos.

```{r, echo=T,  out.width="70%"}
dourados.w <- as.owin(st_geometry(dourados.contorno))
```

#### Extraindo os centr√≥ides dos pol√≠gonos em Dourados/MS

```{r, echo=T,  out.width="70%"}
centroides <- st_centroid(st_geometry(setor.sf))

# Transformando em os centr√≥ides em formato sp (spatstat)
centroides.sp <- as.data.frame(as_Spatial(centroides))
names(centroides.sp) <- c('X','Y')

plot(centroides.sp)
```

### Colocando os pontos no formato sp

```{r, echo=T,  out.width="70%"}
centroides.ppp <- ppp(centroides.sp$X,centroides.sp$Y, dourados.w)

plot(centroides.ppp,pch=19,cex=0.5)
```

### Construindo o kernel por atributo da taxa de detec√ß√£o

```{r, echo=T,  out.width="70%"}
kernel.tx <- density(centroides.ppp, 500, weights = setor.sf$tx, scalekernel = TRUE)
plot(kernel.tx)
```

::: box-dica2

- `centroides.ppp`:	Objeto do tipo ppp com os pontos centrais (centroides) dos setores.
500	Largura de banda (bandwidth), ou seja, o alcance de suaviza√ß√£o da fun√ß√£o kernel, neste caso 500 metros (ou unidades do sistema).

- `weights = setor.sf$tx`: Peso de cada ponto (setor), neste caso uma vari√°vel chamada tx, que provavelmente representa uma taxa (ex: incid√™ncia por popula√ß√£o).

- `scalekernel = TRUE`:	Faz a fun√ß√£o kernel se ajustar automaticamente √† soma total dos pesos, preservando a escala da densidade ponderada.
:::

### Construindo a matriz de vizinhan√ßa para verificar a autocorrela√ß√£o espacial

```{r, echo=T,  out.width="70%"}
library(spdep)
viz <- poly2nb(setor.sf)
viz 
```

::: box-dica2

- `setor.sf` √© um objeto do tipo sf com pol√≠gonos (setores).

- `poly2nb()` (polygon to neighbors) calcula quais pol√≠gonos s√£o vizinhos, ou seja, compartilham ao menos um lado ou ponto de fronteira (por padr√£o).

- `viz` √© um objeto do tipo nb ("neighbors list") ‚Äî uma lista onde cada item cont√©m os √≠ndices dos setores vizinhos ao setor correspondente.

:::

* Iremos precisar da coordenadas dos centr√≥ides para montar a malha de conectividade.

```{r, echo=T,  out.width="70%"}
setor.sp <- as(setor.sf, 'Spatial') # convertendo em formato sp
coord <- coordinates(setor.sp) # coordenadas dos centroidas dos poligonos de dourados
class(setor.sp)
```

### Verificando a malha de conectividade da vizinhan√ßa de Dourados/MS

```{r, echo=T}
viz.sf <- as(nb2lines(viz, coords = coord), 'sf')
viz.sf <- st_set_crs(viz.sf, st_crs(setor.sf))
```

::: box-dica2
- `st_set_crs()` define o sistema de refer√™ncia de coordenadas (CRS) do objeto `viz.sf`.

- Ele est√° copiando o CRS do objeto `setor.sf`, garantindo que os dois objetos estejam no mesmo sistema de coordenadas.
:::

```{r, echo=T,  out.width="70%"}
# Plotando o grafo de conectividade por contiguidade
mapa.viz <- ggplot(setor.sf) + 
  geom_sf(fill = 'lightpink', color = 'white') +
  geom_sf(data = viz.sf) +
  theme_minimal() +
  ggtitle("Vizinhan√ßa por \n conectividade") +
  ylab("Latitude") +
  xlab("Longitude")
mapa.viz
```

### Obtendo a correla√ß√£o da taxa de incid√™ncia de dengue Dourados/MS

- Convertendo a estrutura criada por `poly2nb(setor.sf)` um formato que fun√ß√µes como `moran.test`.

```{r, echo=T}
pesos.viz <- nb2listw(viz)
moran.test(setor.sf$tx, pesos.viz)
```

Podemos observar que existe uma forte autocorrela√ß√£o espacial positiva na vari√°vel `tx`, ou seja, valores semelhantes est√£o espacialmente agrupados. Em outras palavras, setores com valores altos de `tx` tendem a estar pr√≥ximos de outros setores com valores igualmente altos (e o mesmo vale para valores baixos). Esse padr√£o n√£o √© aleat√≥rio, j√° que o p-valor √© muito pequeno, rejeitando a hip√≥tese nula de aus√™ncia de autocorrela√ß√£o espacial.

### Plotando o correlograma

- O correlograma espacial de *Moran‚Äôs I* que voc√™ gerou est√° te mostrando como a autocorrela√ß√£o espacial da vari√°vel `tx` varia conforme o "distanciamento" espacial entre os setores.

```{r, echo=T}
correl <- sp.correlogram(viz, setor.sf$tx, order = 8, method = "I")
correl
```

-A tabela consiste:

  i) `estimate`: o valor observado de Moran‚Äôs I.

  ii) `expectation`: valor esperado sob aleatoriedade (‚âà 0).

  iii) `Pr(I)`: p-valor de signific√¢ncia para cada lag.


```{r, echo=T,  out.width="80%"}
plot(correl)
```


- Nesse gr√°fico podemos observar:

  i) O eixo y mostra o valor de Moran‚Äôs I para cada lag.

  ii) As barras de erro indicam o intervalo de confian√ßa do Moran‚Äôs I em cada lag.

- Podemos compluir ent√£o que:

  * Lag 1 (vizinhos imediatos): Moran‚Äôs I = 0.5367, altamente significativo (*p < 0.001*) $\rightarrow$ forte autocorrela√ß√£o espacial positiva.

  * Lags 2 e 3: valores positivos e ainda significativos $\rightarrow$ padr√£o espacial persiste at√© o terceiro n√≠vel de vizinhan√ßa.

  * Lags 4 a 8: valores negativos ou pr√≥ximos de zero, com signific√¢ncia decrescente ou aus√™ncia de signific√¢ncia $\rightarrow$ a autocorrela√ß√£o desaparece ou se inverte √† medida que a dist√¢ncia aumenta.

### Mapeando os pol√≠gonos que tiveram os p-valores mais significativos no Moran Local.

```{r, echo=T,  out.width="70%"}
setor.sf$pval <- localmoran(setor.sf$tx, pesos.viz)[,5]

tm_shape(setor.sf) + 
  tm_polygons(
    col = "pval",
    title = "p-valores",
    breaks = c(0, 0.01, 0.05, 0.10, 1),
    style = "fixed",
    palette = "-Oranges",
    border.col = "grey"
  )

```

### Moran Local (Lisa Map) da taxa de incid√™ncia Dourados/MS

```{r, echo=T}
resI <- localmoran.sad(lm(setor.sf$tx ~ 1), 1:length(viz), viz, style = "W")
summary(resI)[1:10,]
```

::: box-dica2 

- A fun√ß√£o `localmoran.sad()` calcula o Moran Local `(I·µ¢)` e algumas outras estat√≠sticas associadas para cada pol√≠gono (setor).

- `lm(setor.sf$tx ~ 1)`:  cria um modelo linear sem preditores (apenas o intercepto), ou seja, considera a vari√°vel `tx` como resposta a ser analisada.

- `1:length(viz)`: identifica o √≠ndice de cada √°rea/setor.

- `viz`: √© a estrutura de vizinhan√ßa (do tipo `nb`), que define quem √© vizinho de quem.

- `style = "W"`: define o estilo de normaliza√ß√£o dos pesos espaciais (padroniza√ß√£o row-standardized).

:::

- A est√° mostrando:

  * `Local Morans I`:	Valor do I de Moran local `(I·µ¢)`, indicando se o valor do setor e seus vizinhos s√£o semelhantes (positivo) ou diferentes (negativo).
  
  * `Stand. dev. (N)`:	Desvio padr√£o padronizado da estat√≠stica de Moran local.
  
  * `Pr. (N)`:	p-valor do teste de signific√¢ncia para o valor de `I·µ¢` (baseado na dist. normal).
  
  * `Saddlepoint`:	Valor do I de Moran local corrigido.
  
```{r, echo=T,  out.width="70%"}
setor.sf$MoranLocal <- summary(resI)[,1] 

library(scales)

ggplot(setor.sf) + 
  geom_sf(aes(fill = MoranLocal), color = 'black') +
  scale_fill_gradientn(colours=c("blue", "white", "red"), 
                       values=rescale(c(min(setor.sf$MoranLocal), 0,   max(setor.sf$MoranLocal))), guide="colorbar") + 
  ggtitle("Moran local") + 
  theme_void()
```


Neste mapa, podemos observar:

- Valores altos de Local Morans I com p-valor pequeno indicam clusters estatisticamente significativos:

  * Positivo + significativo $\rightarrow$ cluster alto-alto ou baixo-baixo.

  * Negativo + significativo $\rightarrow$ outlier (ex: um valor alto cercado por baixos, ou o contr√°rio).

### LISA Map

  
```{r, echo=T}
library(spdep)

#  Convertendo uma estrutura de vizinhan√ßa (objeto nb) em uma matriz de pesos espaciais padronizada
w <- nb2listw(viz, style = "W")

# Matriz de pesos espaciais padronizada (row-standardized)
resI <- localmoran(setor.sf$tx, nb2listw(viz, style = "W"))

# Armazena estat√≠sticas no objeto espacial
setor.sf$Ii       <- resI[,1]   # valor de Moran Local
setor.sf$pvalue   <- resI[,5]   # p-valor

# Valor padronizado da vari√°vel tx
setor.sf$z_tx <- scale(setor.sf$tx)[, 1]

# M√©dia dos vizinhos (lagged value)
lag_tx <- lag.listw(w, setor.sf$z_tx)

# Classifica√ß√£o dos tipos de associa√ß√£o local dos clusters
setor.sf$cluster_type <- "N√£o significativo"

setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx > 0 & lag_tx > 0] <- "Alto-Alto"
setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx < 0 & lag_tx < 0] <- "Baixo-Baixo"
setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx > 0 & lag_tx < 0] <- "Alto-Baixo"
setor.sf$cluster_type[setor.sf$pvalue <= 0.05 & setor.sf$z_tx < 0 & lag_tx > 0] <- "Baixo-Alto"


```
  
```{r, echo=T,  out.width="80%"}
library(tmap)

# Modo est√°tico (ideal para relat√≥rios impressos ou PDF)
tmap_mode("plot")

# Tema visual limpo com fundo branco
tmap_style("white")

# Gera√ß√£o do mapa LISA
tm_shape(setor.sf) +
  tm_fill(
    col = "cluster_type",
    palette = c(
      "Alto-Alto"         = "#E60000",  # vermelho forte
      "Baixo-Baixo"       = "#0033CC",  # azul escuro
      "Baixo-Alto"        = "#9999FF",  # azul claro
      "Alto-Baixo"        = "#FF9999",  # rosa claro
      "N√£o significativo" = "#FFFFFF"   # branco
    ),
    title = "Cluster Local (LISA)",
    legend.is.portrait = TRUE
  ) +
  tm_borders(col = "gray40", lwd = 0.4) +
  tm_layout(
    main.title = "Mapa LISA - Clusters Locais da Taxa de Incid√™ncia",
    main.title.size = 1.2,
    legend.outside = TRUE,
    frame = FALSE,
    bg.color = "white"
  )

```
  
# **Aplica√ß√£o IV:** Dengue em Dourados/MS - Parte 2: Modelagem (Modelos Linear, CAR e GWR)



### Ajustando o modelo de regress√£o linear simples.

```{r, echo=T,  out.width="70%"}
# Transformando os missings em zero
setor.sf$lixo[is.na(setor.sf$lixo)] <- 0  

# Ajustando o modelo de regress√£o linear simples
dourados.lm <- lm(tx ~ lixo, data = setor.sf)
summary(dourados.lm)
```

### Checando os residuos para verificar a presen√ßa de autocorrela√ß√£o.

```{r, echo=T,  out.width="70%"}
dourados.lm$lmresid <- residuals(dourados.lm)
moran.test(dourados.lm$lmresid, pesos.viz)
```

### Ajustando o modelo CAR (Spatial Error Model)

O **Modelo de Erro Espacial** (*Spatial Error Model* - **CAR**), representado por:
    
$$y_i = \beta_0 + \sum^{p}_{k} \beta_k x_{ik}  + \varepsilon_i$$
$$\varepsilon_i = \lambda  W + \xi$$

```{r, echo=T,  out.width="70%"}
library(spatialreg)
dourados.car <- errorsarlm(tx ~ lixo, data = setor.sf, listw = pesos.viz)
summary(dourados.car)
```

::: box-dica1

* Lambda ($Œª = 0.816$) √© o par√¢metro de autocorrela√ß√£o espacial dos erros. Se Um valor de lambda fosse pr√≥ximo de 0, pouca ou nenhuma autocorrela√ß√£o espacial nos erros, ou seja, modelo linear tradicional pode ser suficiente.

* Testes (*LR, z, Wald*) mostram que esse par√¢metro √© altamente significativo ($p-value < 2.22e-16$), ou seja, h√° autocorrela√ß√£o espacial nos res√≠duos, justificando o uso de um modelo espacial ao inv√©s de um modelo cl√°ssico.

* A vari√¢ncia residual estimada √© de 23.437.

* O modelo espacial tem AIC menor que o modelo cl√°ssico (lm):
AIC spatial $=$ 1756.5 $<$ AIC lm $=$ 1931.1, o que indica que o modelo com erro espacial se ajusta melhor aos dados.

:::

- A vari√°vel explicativa lixo n√£o foi estatisticamente significativa neste modelo.

- H√° forte evid√™ncia de autocorrela√ß√£o espacial nos erros, o que valida a escolha por um modelo do tipo `errorsarlm`.

- O modelo espacial se ajusta melhor do que o modelo tradicional (lm), segundo o crit√©rio AIC.

### Checando os residuos para verificar a presen√ßa de autocorrela√ß√£o

```{r, echo=T,  out.width="70%"}
dourados.car$carresid <- residuals(dourados.car)
moran.test(dourados.car$carresid, pesos.viz)
```

Como o $p-valor = 0.2531 > 0.05$, n√£o rejeitamos a hip√≥tese nula de aus√™ncia de autocorrela√ß√£o espacial nos res√≠duos. Isso indica que o modelo `errorsarlm` eliminou adequadamente a autocorrela√ß√£o espacial presente nos dados. 

Esse √© exatamente o objetivo do modelo `errorsarlm`, capturar a estrutura espacial nos erros. E a aus√™ncia de autocorrela√ß√£o nos res√≠duos valida a adequa√ß√£o desse modelo para os seus dados.


### Ajustando o modelo GWR (Geographically Weighted Regression)

```{r, echo=T,  out.width="70%"}
# Biblioteca para ajustar o modelos GWR
library(spgwr)

# Estimando a largura de banda ‚Äúideal‚Äù para o kernel
GWRbanda <- gwr.sel(tx ~ lixo, data = setor.sf, coords = cbind(centroides.sp$X, centroides.sp$Y), adapt = T)
```

::: box-dica2

- Carregando o pacote `spgwr`, que √© usado para rodar regress√µes ponderadas geograficamente (GWR). Essa t√©cnica permite que os coeficientes variem no espa√ßo, ou seja, ela mostra como o efeito de uma vari√°vel muda de lugar para lugar.

- `gwr.sel()` √© uma fun√ß√£o que ajuda a escolher a largura de banda (bandwidth) "ideal" para o modelo GWR. A largura de banda controla o raio de influ√™ncia espacial ao redor de cada ponto (quais vizinhos t√™m mais peso).

  * Quanto menor a banda $rightarrow$ modelo mais local (mais sens√≠vel ao espa√ßo).

  * Quanto maior $rightarrow$ modelo mais global (menos sens√≠vel ao espa√ßo).

**OBS:** Esse valor de `q` representa a propor√ß√£o de vizinhos usada para construir o kernel. Depois, ao ajustar o modelo com a fun√ß√£o `gwr()`, ser√° calculada internamente a dist√¢ncia f√≠sica real correspondente em metros para cada ponto com base nas coordenadas UTM.  
:::

```{r, echo=T,  out.width="70%"}
# Ajustando o modelo GWR
dourados.gwr = gwr(tx ~ lixo, data = setor.sf, coords = cbind(centroides.sp$X, centroides.sp$Y), adapt = GWRbanda, hatmatrix = TRUE, se.fit = TRUE)

dourados.gwr
```

::: box-dica2

- `coords = cbind(X, Y)`:	Coordenadas dos pontos onde ser√° ajustado o modelo (em nosso caso s√£o os centroides dos setores).

- `adapt = GWRbanda`:	Usando a largura de banda adaptativa "ideal" j√° estimada (GWRbanda), que define o raio de influ√™ncia espacial.

- `hatmatrix = TRUE`:	Retorna a matriz com estimativas usadas para c√°lculos como AIC e diagn√≥stico de res√≠duos.

- `se.fit = TRUE`:	Calcula os erros padr√£o das estimativas locais dos coeficientes.

:::

Esse modelo permite analisar como o efeito da vari√°vel `lixo` sobre `tx` muda de um local para outro. Em vez de um √∫nico coeficiente como na regress√£o tradicional, o GWR estima um coeficiente diferente para cada setor do mapa.


::: box-dica1

* `Kernel function: gwr.Gauss` ‚Üí O modelo usou um kernel gaussiano, que atribui mais peso a vizinhos pr√≥ximos.

* `Adaptive quantile: 0.005127099` ‚Üí Como `adapt = TRUE`, a largura de banda representa uma propor√ß√£o dos pontos vizinhos.

- Quanto aos coeficientes do modelo, cada linha refere-se √† distribui√ß√£o dos coeficientes locais estimados em cada ponto do espa√ßo (284 no total). 

  * Por exemplo, o impacto da vari√°vel `lixo` sobre `tx` varia bastante no espa√ßo. Em alguns lugares pode ser fortemente negativo ($-20.43$), em outros levemente positivo ($+1.57$).
  
  * A coluna `Global` mostra o coeficiente que seria obtido numa regress√£o tradicional (OLS).
  
- `Sigma (residual)`:	Desvio padr√£o dos res√≠duos do modelo GWR.

- `AIC (GWR)`: 	Crit√©rio de informa√ß√£o de Akaike (quanto menor, melhor). √ötil para comparar com OLS.

- `AICc (corrigido)`: Vers√£o do AIC corrigida para modelos com muitos par√¢metros.

- `Residual sum of squares`: Soma dos quadrados dos res√≠duos (menor = melhor ajuste).

- `Quasi-global R¬≤`: Explica $~74%$ da variabilidade de `tx`. Excelente ajuste para dados espaciais.

:::

‚úÖ  Podemos observar  atrav√©s do ajuste do modelo que:

* O modelo GWR encontrou varia√ß√µes espaciais significativas na rela√ß√£o entre lixo e tx.

* Os coeficientes de lixo mudam no espa√ßo, variando de fortemente negativos a levemente positivos.

* O Quasi-R¬≤ de $74\%$ indica que o modelo explica bem os dados.

* A redu√ß√£o do AIC em rela√ß√£o ao modelo OLS (que tinha $AIC ‚âà 1931$) refor√ßa a adequa√ß√£o do GWR.


```{r, echo=T,  out.width="70%"}
# Colocando a sa√≠da do modelo dentro de um objeto dataframe.
results <- as.data.frame(dourados.gwr$SDF)
head(results)
```

### Verificando a distribui√ß√£o dos coeficientes de regress√£o para a vari√°vel lixo

```{r, echo=T,  out.width="80%"}
hist(results$lixo)
abline(v = median(results$lixo), col = "red")
```

### Verificando a distribui√ß√£o dos *localR2*

```{r, echo=T,  out.width="80%"}
hist(results$localR2)
abline(v = median(results$localR2), col = "blue")
```

### Incorporando alguns par√¢metros de sa√≠da do modelo na tabela *setor.sf*

```{r, echo=T,  out.width="70%"}
setor.sf$coef.lixo <- results$lixo
setor.sf$localR2 <- results$localR2
setor.sf$pred.gwr <- results$pred
```

### Mapa dos coeficientes de regress√£o para a vari√°vel lixo

```{r, echo=T,  out.width="80%"}
map.lixo <- ggplot(setor.sf) +
  geom_sf(aes(fill = coef.lixo), color = "black", size = 0.1) +
  scale_fill_gradient2(
    low = "blue",      # para coeficientes negativos
    mid = "white",     # para valores pr√≥ximos de zero
    high = "darkred",      # para coeficientes positivos
    midpoint = 0,      # centraliza a escala no zero
    name = "Coef. lixo"
  ) +
  ggtitle("Coef locais da vari√°vel lixo") +
  theme_void()

map.lixo

```

### Checando os residuos para verificar a presen√ßa de autocorrela√ß√£o para o modelo GWR.

```{r, echo=T,  out.width="70%"}
# Calculando os res√≠duos para o modelo GWR
results$residuos <- setor.sf$tx - results$pred

moran.test(results$residuos, pesos.viz)
```

### Mapeando os coeficientes de regress√£o para a vari√°vel lixo por significancia atrav√©s do teste de wald

O teste de Wald √© utilizado para avaliar a signific√¢ncia estat√≠stica dos coeficientes estimados em modelos de regress√£o, como a Regress√£o Ponderada Geograficamente (GWR). A estat√≠stica de Wald testa se o coeficiente estimado (\(\hat{\beta}\)) √© significativamente diferente de zero, com base no seu erro padr√£o (\(SE(\hat{\beta})\)).

A f√≥rmula geral do teste √©:

\[
W = \frac{|\hat{\beta}|}{SE(\hat{\beta})}
\]

Valores altos da estat√≠stica de Wald indicam maior evid√™ncia de que o coeficiente √© significativamente diferente de zero. Sob a hip√≥tese nula (\(H_0: \beta = 0\)), a estat√≠stica de Wald segue uma distribui√ß√£o normal padr√£o.

No contexto do modelo GWR, o teste de Wald foi aplicado ponto a ponto para o coeficiente local da vari√°vel `lixo`, utilizando a raz√£o entre o valor absoluto do coeficiente estimado e seu erro padr√£o.

Para fins de mapeamento, a estat√≠stica foi dicotomizada da seguinte forma:

\[
\texttt{wald.teste} =
\begin{cases}
1 & \text{se } W \geq 2 \ (\text{coeficiente significativo}) \\
0 & \text{se } W < 2 \ (\text{coeficiente n√£o significativo})
\end{cases}
\]

O limiar de 2 foi escolhido por ser uma aproxima√ß√£o pr√°tica do ponto de corte para um n√≠vel de signific√¢ncia de 5\% (como \(z = 1.96\) na distribui√ß√£o normal padr√£o).

Essa abordagem permite visualizar espacialmente onde a vari√°vel `lixo` exerce um efeito estatisticamente significativo sobre a vari√°vel dependente `tx`.


```{r, echo=T,  out.width="100%"}
# Calculando a estat√≠stica de wald
setor.sf$wald.teste <- abs(results$lixo/results$lixo_se)

# Dicotomizando a estat√≠stica de wald
setor.sf$wald.teste <- ifelse(setor.sf$wald.teste < 2, 0, 1)


map.wald <- ggplot(setor.sf) + geom_sf(aes(fill = factor(wald.teste)), color = "black") + 
  scale_fill_manual(values = c("white", "purple"), labels = c("< 2", ">= 2"), name = "Wald") + 
  ggtitle("Coef. lixo significativos") + theme_void()


library(gridExtra)
grid.arrange(map.lixo, map.wald, ncol = 2)

```

### Mapa dos coeficientes de determina√ß√£o regionalizados ($R^2$ local).

```{r, echo=T,  out.width="90%"}
ggplot(setor.sf) +
  geom_sf(aes(fill = localR2), color = "black", size = 0.1) +
  scale_fill_viridis_c(option = "viridis",, direction = -1, name = expression(R^2~local)) +
  ggtitle("Mapa dos coeficientes de determina√ß√£o regionalizados (R¬≤ local)") +
  theme_void()

```

### Verificando a distribui√ß√£o dos preditos.

```{r, echo=T,  out.width="100%"}
histdens <- function(x, titulo = "") {
  densi <- density(x)
  xli <- range(densi$x)
  yli <- range(densi$y)
  hist(x, col = "orange", probability = T, xlim = xli, ylim = yli, main = titulo)
  lines(densi, lwd = 2)
  abline(v = median(x), lwd = 2, col = "blue", lty = 2)
}

par(mfrow = c(2, 2))

hist.tx <- histdens(setor.sf$tx, "Tx Bruta")
hist.lm <- histdens(dourados.lm$fitted.values, "Pred LM")
hist.car <- histdens(dourados.car$fitted.values, "Pred CAR")
hist.gwr <- histdens(results$pred, "Pred GWR")
```

| Modelo       | Ades√£o √† distribui√ß√£o real       | Interpreta√ß√£o                                                                 |
|--------------|----------------------------------|-------------------------------------------------------------------------------|
| **Tx Bruta** | ‚Äî                                | Distribui√ß√£o assim√©trica e dispersa (refer√™ncia real)                         |
| **Pred LM**  | ‚ùå Fraca                         | Muito concentrado, n√£o capta a variabilidade; achatamento da distribui√ß√£o     |
| **Pred CAR** | ‚úÖ Razo√°vel                      | Captura parte da variabilidade, mas suaviza a dispers√£o                      |
| **Pred GWR** | ‚úÖ‚úÖ Melhor                      | Preserva assimetria, cauda e dispers√£o; melhor ajuste √† estrutura espacial   |


Apesar dos modelos analisarem apenas o efeito da vari√°vel `lixo` sobre a taxa `tx`, observa-se que o modelo `GWR` foi o √∫nico capaz de gerar uma distribui√ß√£o de preditos que preserva, em boa parte, a forma assim√©trica e a dispers√£o da vari√°vel observada. Isso indica que o impacto de `lixo` sobre `tx` n√£o √© homog√™neo e varia conforme a localiza√ß√£o. Modelos tradicionais como o `LM`, ao assumirem um coeficiente global, subestimam a variabilidade local, enquanto modelos espaciais (CAR) ou locais (GWR) conseguem representar melhor essa rela√ß√£o dependente do espa√ßo.


### Mapeando os valores observados e preditos dos modelos ajustados

```{r, echo=T,  out.width="100%"}
library(RColorBrewer)

# Define faixas de classes abrangentes
breaks_classes <- c(-Inf, 0, 2, 4, 10, Inf)
labels_classes <- c("< 0", "0 - 2", "2 - 4", "4 - 10", "> 10")

# -----------------------------------------
# Taxa Bruta Observada
setor.sf$brks <- cut(setor.sf$tx,
                     breaks = breaks_classes,
                     include.lowest = TRUE,
                     right = TRUE,
                     labels = labels_classes)

tx.bruta <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks), color = "black", size = 0.1) +
  scale_fill_brewer(palette = "YlOrRd", name = "Taxa") +
  ggtitle("Taxa Bruta") +
  theme_void()

# -----------------------------------------
# Predito - LM
setor.sf$brks.lm <- cut(dourados.lm$fitted.values,
                        breaks = breaks_classes,
                        include.lowest = TRUE,
                        right = TRUE,
                        labels = labels_classes)

pred.lm <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks.lm), color = "black", size = 0.1) +
  scale_fill_brewer(palette = "YlOrRd", name = "Taxa") +
  ggtitle("Taxa Predita - LM") +
  theme_void()

# -----------------------------------------
# Predito - CAR
setor.sf$brks.car <- cut(dourados.car$fitted.values,
                         breaks = breaks_classes,
                         include.lowest = TRUE,
                         right = TRUE,
                         labels = labels_classes)

pred.car <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks.car), color = "black", size = 0.1) +
  scale_fill_brewer(palette = "YlOrRd", name = "Taxa") +
  ggtitle("Taxa Predita - CAR") +
  theme_void()

# -----------------------------------------
# Predito - GWR
setor.sf$brks.gwr <- cut(results$pred,
                         breaks = breaks_classes,
                         include.lowest = TRUE,
                         right = TRUE,
                         labels = labels_classes)

pred.gwr <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks.gwr), color = "black", size = 0.1) +
  scale_fill_brewer(palette = "YlOrRd", name = "Taxa") +
  ggtitle("Taxa Predita - GWR") +
  theme_void()

# -----------------------------------------
# Mostrar mapas lado a lado
grid.arrange(tx.bruta, pred.lm, pred.car, pred.gwr, ncol = 2)


```



### Comparando a distribui√ß√£o dos res√≠duos dos modelos ajustados

```{r, echo=T,  out.width="90%"}
library(vioplot)

# Define os res√≠duos
res_lm  <- dourados.lm$residuals
res_car <- dourados.car$residuals
res_gwr <- results$residuos

# Paleta de cores agrad√°vel
cores <- c("#66C2A5", "#FC8D62", "#8DA0CB")  # Paleta Set2 do RColorBrewer

# Gr√°fico violin com visual melhorado
vioplot(
  res_lm, res_car, res_gwr,
  names = c("LM", "CAR", "GWR"),
  col = cores,
  border = "black",
  drawRect = TRUE     # mediana dos res√≠duos
)

# T√≠tulo e r√≥tulo do eixo Y
title(main = "Distribui√ß√£o dos Res√≠duos por Modelo", cex.main = 1.2)
mtext("Res√≠duos", side = 2, line = 2.5, cex = 1.1)

# Linha horizontal em y = 0 para refer√™ncia
abline(h = 0, lty = 2, col = "grey40")

```

A partir dos gr√°ficos, podemos observar que:

- O modelo GWR apresenta os res√≠duos mais bem comportados, com menor dispers√£o e centrados em zero, sugerindo melhor ajuste aos dados.

- O modelo CAR melhora o ajuste em rela√ß√£o ao LM, ao levar em conta a depend√™ncia espacial.

- J√° o modelo LM apresenta maior erro residual, especialmente nas regi√µes com taxas elevadas, o que refor√ßa a import√¢ncia de considerar a dimens√£o espacial.


### Mapeando os res√≠duos dos modelos ajustados

```{r, echo=T,  out.width="100%"}
library(colorspace)

# Quebras e r√≥tulos
breaks_res <- c(-14, -5, -1, 1, 5, 52)
labels_res <- c("< -5", "-5 a -1", "0", "1 a 5", "> 5")

# ------------------------------
# Res√≠duos - LM
setor.sf$brks.res.lm <- cut(dourados.lm$residuals,
                            breaks = breaks_res,
                            labels = labels_res,
                            include.lowest = TRUE,
                            right = TRUE)

res.lm <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks.res.lm), color = "black", size = 0.1) +
  scale_fill_discrete_sequential(
    palette = "Purple-Yellow",
    name = "Res√≠duo",
    na.value = "grey75",
    drop = FALSE
  ) +
  ggtitle("Res√≠duos - LM") +
  theme_void()

# ------------------------------
# Res√≠duos - CAR
setor.sf$brks.res.car <- cut(dourados.car$residuals,
                             breaks = breaks_res,
                             labels = labels_res,
                             include.lowest = TRUE,
                             right = TRUE)

res.car <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks.res.car), color = "black", size = 0.1) +
  scale_fill_discrete_sequential(
    palette = "Purple-Yellow",
    name = "Res√≠duo",
    na.value = "grey75",
    drop = FALSE
  ) +
  ggtitle("Res√≠duos - CAR") +
  theme_void()

# ------------------------------
# Res√≠duos - GWR
setor.sf$brks.res.gwr <- cut(results$residuos,
                             breaks = breaks_res,
                             labels = labels_res,
                             include.lowest = TRUE,
                             right = TRUE)

res.gwr <- ggplot(setor.sf) +
  geom_sf(aes(fill = brks.res.gwr), color = "black", size = 0.1) +
  scale_fill_discrete_sequential(
    palette = "Purple-Yellow",
    name = "Res√≠duo",
    na.value = "grey75",
    drop = FALSE
  ) +
  ggtitle("Res√≠duos - GWR") +
  theme_void()

# ------------------------------
# Exibir mapas
grid.arrange(res.lm, res.car, res.gwr, ncol = 2)

```

# **Aplica√ß√£o V:** Geoestat√≠stica com dados de pluviosidade na cidade do Rio de Janeiro/RJ

Nesta aplica√ß√£o, utilizaremos t√©cnicas de geoestat√≠stica para analisar os dados de chuva acumulada provenientes das esta√ß√µes pluviom√©tricas do sistema Alerta Rio. Os dados referem-se √† m√©dia da precipita√ß√£o acumulada em 7 dias, com base nos totais das √∫ltimas 24h e 96h, permitindo uma vis√£o mais abrangente da distribui√ß√£o espacial da chuva no munic√≠pio.

Atrav√©s do uso de bibliotecas do R espec√≠ficas para an√°lise espacial e interpola√ß√£o, o objetivo √© construir modelos geoestat√≠sticos que possibilitem a interpola√ß√£o dos valores de precipita√ß√£o em regi√µes n√£o monitoradas diretamente por esta√ß√µes. Esse tipo de abordagem pode auxiliar tanto no planejamento urbano quanto na preven√ß√£o de desastres naturais.

### Biliotecas do R que ser√£o utilizadas

```{r, echo=T}
library(sf)
library(sp)
library(dplyr)
library(gstat)
library(lattice)
library(automap)
library(raster)
library(leaflet)
```

### Importando a tabela com a chuva acumulada m√©dia de 7 dias das √∫ltimas 24hs e 96hs das esta√ß√µes pluviom√©tricas da cidade do Rio de Janeiro

[Descri√ß√£o das Esta√ß√µes (Alerta Rio)](http://www.sistema-alerta-rio.com.br/dados-meteorologicos/info-estacoes/)

[Download Dados Pluviom√©tricos (Alerta Rio)](http://www.sistema-alerta-rio.com.br/dados-meteorologicos/download/dados-pluviometricos/)

* Como esses dados j√° foram baixados, iremos ler direto no R:

```{r, echo=T}
# 
pluvio <- read.csv("dados/chuva_rio/pluviosidade.csv", sep=";")
```

### An√°lise Gr√°fica Descritiva 

```{r, echo=T}
quantil <- quantile(pluvio$acumulado_24h, seq(0,1,0.2))
quantil
```

### Transformar os dados em um objeto espacial do R

* x - Longitude
* y - Latitude

```{r, echo=T}
sp::coordinates(pluvio) = ~ x + y
```

### An√°lise Gr√°fica Descritiva com os dados espaciais

```{r, echo=T,  out.width="90%"}
# Bubble plot
bubble(pluvio, "acumulado_24h", key.entries = quantil, pch=19, col="blue")
```

```{r, echo=T,  out.width="90%"}
# Point plot
spplot(pluvio['acumulado_24h'], scales=list(draw=T), key.space="right", colorkey=T)
```

### üìå Variograma Experimental (ou emp√≠rico)

O variograma experimental (ou emp√≠rico) √© uma ferramenta usada em geoestat√≠stica para medir como a semelhan√ßa entre os valores de uma vari√°vel muda com a dist√¢ncia entre os pontos amostrados. Nesse caso, o variograma experimental vai nos ajudar a entender qu√£o relacionados est√£o os valores de chuva conforme a dist√¢ncia entre as esta√ß√µes pluviom√©tricas aumenta.

üß™ Como √© constru√≠do ?

1. Para v√°rios pares de pontos, calcula-se a diferen√ßa entre os valores medidos (por exemplo, de chuva em 24h).

2. Agrupa-se esses pares por faixas de dist√¢ncia (os "lags").

3. Para cada faixa, calcula-se a m√©dia da vari√¢ncia entre os pares.

üß† Por que √© importante ?

1. O variograma experimental √© a base para escolher e ajustar um modelo geoestat√≠stico.

2. Ele permite aplicar m√©todos como krigagem, para estimar valores em locais sem medi√ß√£o.


```{r, echo=T}
variogram.emp = variogram(acumulado_24h ~x+y, pluvio, width=1000, cutoff=20000)
variogram.emp
```

::: box-dica2

- `acumulado_24h ~ x + y`: estamos analisando como a vari√°vel chuva acumulada varia no espa√ßo (coordenadas x e y).

- `width = 1000`: define que os pares de pontos ser√£o agrupados em intervalos de 1000 metros, ou seja, √© aist√¢ncia m√©dia entre amostras ou dist√¢ncia dos lags.

- `cutoff = 20000`: s√≥ ser√£o considerados pares de pontos com at√© 20 km de dist√¢ncia (Dist√¢ncia m√°xima entre os pontos amostrados).
:::



```{r, echo=T}
# Variogram plot
plot(variogram.emp, main = "Empirical variogram", pch = 19, col = "darkblue")
```

::: box-dica2

Esse c√≥digo plota o variograma experimental (ou emp√≠rico), que foi criado anteriormente com o objeto `variogram.emp`.

:::

O variograma emp√≠rico mostra que h√° uma autocorrela√ß√£o espacial positiva entre os pontos amostrados at√© aproximadamente 10.000 unidades de dist√¢ncia. Ap√≥s esse ponto, a semivari√¢ncia se estabiliza, sugerindo que a depend√™ncia espacial se dissipa. Oscila√ß√µes em maiores dist√¢ncias podem indicar varia√ß√£o n√£o explicada (efeito pepita) ou padr√µes espaciais mais complexos.

### üìå Semivariograma Te√≥rico

√â uma fun√ß√£o matem√°tica ajustada sobre o variograma experimental. Ele serve para modelar a rela√ß√£o espacial entre os dados (ex: chuva), e √© usado para realizar interpola√ß√µes com krigagem.

üü° **Nugget (efeito pepita)**:  √â o valor do variograma no ponto zero da dist√¢ncia ($x = 0$).

‚ö´ **Sill (patamar ou limite da vari√¢ncia)**: √â o valor m√°ximo da semivari√¢ncia (eixo $Y$), onde a curva estabiliza. Indica o ponto em que os dados deixam de estar correlacionados espacialmente.

üìè **Range (alcance)**: √â a dist√¢ncia (eixo $X$) at√© onde os dados ainda est√£o correlacionados. Depois do range, os pontos n√£o t√™m mais rela√ß√£o espacial entre si.

ü§î Por que isso importa ?

Esses tr√™s par√¢metros (nugget, sill e range) definem como a vari√°vel se comporta no espa√ßo, e s√£o essenciais para:

* Interpolar dados em locais sem observa√ß√£o (krigagem),

* Planejar amostragem eficiente,

* Entender o grau de continuidade espacial de um fen√¥meno.


```{r echo=F, fig.align="center", out.width= "70%", fig.show='hold'}
include_graphics('figuras/variograma_model.png')
```

[Fonte do gr√°fico](https://vsp.pnnl.gov/help/Vsample/Kriging_Variogram_Model.htm)

üìå Alguns modelos mais usuais para o ajuste do variograma teorico:

```{r variograma-teorico, echo=FALSE, message=FALSE, warning=FALSE}
library(gstat)
library(ggplot2)
library(dplyr)

psill <- 80
range <- 12000
nugget <- 15
h <- seq(1, 20000, length.out = 200)

lin <- variogramLine(vgm(psill, "Lin", range, nugget), dist_vector = h) |> mutate(Modelo = "Linear")
exp <- variogramLine(vgm(psill, "Exp", range, nugget), dist_vector = h) |> mutate(Modelo = "Exponencial")
gau <- variogramLine(vgm(psill, "Gau", range, nugget), dist_vector = h) |> mutate(Modelo = "Gaussiano")
wav <- suppressWarnings(na.omit(variogramLine(vgm(psill, "Wav", range, nugget), dist_vector = h))) |> mutate(Modelo = "Wave")

p0 <- data.frame(dist = 0, gamma = nugget)
p0_list <- lapply(c("Linear", "Exponencial", "Gaussiano", "Wave"), \(m) cbind(p0, Modelo = m))

dados <- bind_rows(p0_list[[1]], p0_list[[2]], p0_list[[3]], p0_list[[4]],
                   lin, exp, gau, wav)

dados <- dados %>% filter(!is.na(gamma) & is.finite(gamma))

ggplot(dados, aes(x = dist, y = gamma, color = Modelo, linetype = Modelo)) +
  geom_line(size = 1.2) +
  labs(title = "Modelos Te√≥ricos de Variograma",
       x = "Dist√¢ncia", y = "Semivari√¢ncia") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "bottom",
    legend.title = element_blank(),
    plot.title = element_text(face = "bold", hjust = 0.5),
    axis.line = element_line(color = "black"),
    panel.grid = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )
```


üìå Par√¢metros sugeridos para ajuste do variograma te√≥rico:

Observando o Variograma Emp√≠rico, √© poss√≠vel sugerir os tr√™s par√¢metros principais que definem a estrutura espacial dos dados:

| Par√¢metro                  | Significado                                                                        | Interpreta√ß√£o visual no seu gr√°fico                                                                          |
| -------------------------- | ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **Nugget (efeito pepita)** | Varia√ß√£o a dist√¢ncia zero (ru√≠do, erro de medi√ß√£o, microvaria√ß√£o)                  | O valor de semivari√¢ncia onde o gr√°fico come√ßa. Visualmente est√° entre **10 e 15**                           |
| **Range (alcance)**        | Dist√¢ncia onde a semivari√¢ncia se estabiliza (pontos al√©m disso s√£o independentes) | A estabiliza√ß√£o parece ocorrer por volta de **10.000 a 12.000 unidades de dist√¢ncia**                        |
| **Sill (plat√¥)**           | Valor m√°ximo da semivari√¢ncia (nugget + psill)                                     | O plat√¥ est√° pr√≥ximo de **80 a 100**, portanto o `psill` seria algo como **70 a 90** (psill = sill - nugget) |



```{r, echo=T}
## 1) Modelo Linear
lin.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 80, model = "Lin",
                                     range = 12000, nugget = 15))

## 2) Modelo exponencial
exp.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 80, model = "Exp",
                                     range = 12000, nugget = 15))

## 3) Modelo gaussiano
gau.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 80, model = "Gau",
                                     range = 12000, nugget = 15))

## 4) Modelo wave
wav.fit  = fit.variogram(variogram.emp, 
                         model = vgm(psill = 80, model = "Wav",
                                     range = 12000, nugget = 15))

```

::: box-dica2

Os comandos usam a fun√ß√£o `fit.variogram()` do pacote `gstat` no R para ajustar modelos te√≥ricos ao variograma emp√≠rico (representado pelo objeto `variogram.emp` da figura acima). Isso √© essencial para modelar a depend√™ncia espacial entre os dados.

Os modelos ajustados foram: Modelo Linear (`Lin`), Exponencial (`Exp`), Gaussiano (`Gau`) e Wave (`Wav`). Para o ajuste dos mpdels, foram utilizados os seguintes par√¢mentros que definem a estrutura espacial dos dados:

- `model`: tipo de modelo te√≥rico (forma da curva).

- `psill`: efeito de plat√¥ (sill parcial).

- `range`: alcance da depend√™ncia espacial.

- `nugget`: efeito pepita (varia√ß√£o n√£o explicada, ru√≠do ou erro de medi√ß√£o).

:::

```{r echo=FALSE, out.width="90%"}
# Layout: 2 linhas, 2 colunas
par(mfrow = c(2, 2))

# Plota cada modelo com linha vermelha
plot(variogram.emp, lin.fit, main = "Modelo Linear", col.line = "red")
plot(variogram.emp, exp.fit, main = "Modelo Exponencial", col.line = "red")
plot(variogram.emp, gau.fit, main = "Modelo Gaussiano", col.line = "red")
plot(variogram.emp, wav.fit, main = "Modelo Wave", col.line = "red")

# Restaura o layout padr√£o
par(mfrow = c(1, 1))
```


### üß™ Valida√ß√£o Cruzada 

A valida√ß√£o cruzada √© um processo utilizado para avaliar o desempenho do modelo de krigagem. No contexto espacial, ela consiste em retirar um ponto por vez da malha de dados, utilizar os demais pontos para prever o valor naquele local removido, comparar a previs√£o com o valor real observado e repetir esse procedimento para todos os pontos da amostra. Esse m√©todo permite estimar a capacidade do modelo em gerar boas predi√ß√µes em locais onde n√£o h√° observa√ß√µes diretas.

üßÆ O que √© o **RMSE (Root Mean Squared Error)**: √© um dos indicadores que resume a performance do modelo. √â a "a raiz quadr√°tica m√©dia" dos erros entre valores observados (reais) e predi√ß√µes (hip√≥teses).

$$\text{RMSE} = \sqrt{ \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2 }$$

### Modelo Linear

```{r, echo=T}
## 1) Modelo Linear
cv.lin <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = lin.fit)
summary(cv.lin)
```

::: cox-dica2

- Executando a valida√ß√£o cruzada do modelo de krigagem linear (`lin.fit`) aplicado aos dados de precipita√ß√£o `acumulado_24h` com base nas coordenadas `x` e `y`.

- `krige.cv()`: fun√ß√£o do pacote `gstat` que realiza a valida√ß√£o cruzada.

- `locations = pluvio`, indica que os pontos est√£o no objeto espacial pluvio.

- Armazena o resultado (res√≠duos, predi√ß√µes, observa√ß√µes, etc.) no objeto `cv.lin`.

- `summary(cv.lin)`: Mostra estat√≠sticas descritivas da predi√ß√£o (`var1.pred`), valor observado (`observed`) e res√≠duo (`residual`).
:::

```{r, echo=T}
plot(cv.lin$var1.pred ~ cv.lin$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_lin <- lm(cv.lin$var1.pred ~ cv.lin$observed)
abline(lm_lin, col = "red", lwd = 2)
r2_lin = summary(lm_lin)$r.squared
rmse_lin = hydroGOF::rmse(cv.lin$var1.pred, cv.lin$observed)
```


::: cox-dica2

- Plota os valores preditos em fun√ß√£o dos valores observados. Serve para visualizar a qualidade das previs√µes. 

- Ajusta um modelo linear entre predito e observado. Adiciona essa linha ao gr√°fico em vermelho, indicando o ajuste real das predi√ß√µes. Quanto mais pr√≥ximos da linha cinza $45¬∞$ <span style="color:#808080;">‚óè</span>, melhor o modelo.

:::

### Modelo Exponencial

```{r, echo=T}
## 2) Modelo exponencial
cv.exp <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = exp.fit)
summary(cv.exp)
```

```{r, echo=T}
plot(cv.exp$var1.pred ~ cv.exp$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_exp <- lm(cv.exp$var1.pred ~ cv.exp$observed)
abline(lm_exp, col = "red", lwd = 2)
r2_exp = summary(lm_exp)$r.squared
rmse_exp = hydroGOF::rmse(cv.exp$var1.pred, cv.exp$observed)

```

### Modelo Gaussiano


```{r, echo=T}
## 3) Modelo Gaussiano
cv.gau <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = gau.fit)
summary(cv.gau)

```


```{r, echo=T}
plot(cv.gau$var1.pred ~ cv.gau$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_gau <- lm(cv.gau$var1.pred ~ cv.gau$observed)
abline(lm_gau, col = "red", lwd = 2)
r2_gau = summary(lm_gau)$r.squared
rmse_gau = hydroGOF::rmse(cv.gau$var1.pred, cv.gau$observed)

```

### Modelo Wave

```{r}
## 4) Modelo Wave
cv.wav <- krige.cv(acumulado_24h ~x+y, locations = pluvio, model = wav.fit)
summary(cv.wav)
```


```{r, echo=T}
plot(cv.wav$var1.pred ~ cv.wav$observed, cex = 1.2, lwd = 2)
abline(0, 1, col = "lightgrey", lwd = 2)
lm_wav <- lm(cv.wav$var1.pred ~ cv.wav$observed)
abline(lm_wav, col = "red", lwd = 2)
r2_wav = summary(lm_wav)$r.squared
rmse_wav = hydroGOF::rmse(cv.wav$var1.pred, cv.wav$observed)
```

### üìã Tabela das estat√≠stica de $R^2$ e $RMSE$

```{r, echo=T}
# Criando um data frame com os nomes dos modelos
modelos <- c("Linear", "Exponencial", "Gaussiano", "Wave")

# Combinando os valores de R¬≤ e RMSE em um √∫nico data frame
tabela_desempenho <- data.frame(
  Modelo = modelos,
  R2 = c(r2_lin, r2_exp, r2_gau, r2_wav),
  RMSE = c(rmse_lin, rmse_exp, rmse_gau, rmse_wav)
)

# Visualizando a tabela
print(tabela_desempenho)

```

Apesar de todos os modelos apresentarem $R^2$ baixos (indicando que os modelos explicam uma parcela limitada da variabilidade dos dados), o modelo linear se destacou como o mais eficiente nesse conjunto de dados, tanto por explicar mais da vari√¢ncia da vari√°vel resposta (acumulado de chuva) quanto por apresentar o menor erro m√©dio de previs√£o.




### Criando os grids do contorno da cidade do Rio de Janeiro para intermpola√ß√£o

```{r, echo=T, message=FALSE, warning=FALSE, results='hide'}
# Importando o contorno do Rio
contorno.rio <- shapefile("dados/chuva_rio/MUNIC_2K_2022_IPP_SIRGAS.shp")

# Ou usar o comando

# contorno.rio <- st_geometry(read_municipality(code_muni = 3304557, year = 2022))
```

::: box-dica2

Criando um objeto com apenas o contorno do pol√≠gono da cidade do Rio de Janeiro.
:::

```{r, echo=T, echo=T, message=FALSE, warning=FALSE, results='hide'}
# Criando grade para interpolacao com a  resolucao de 50m
r <- raster(contorno.rio, res = 50)

# Criando um objeto formato raster
rp <- rasterize(contorno.rio, r, 0) 

# Trasnsformando o objeto raster no formato SpatialPixelsDataFrame
grid <- as(rp, "SpatialPixelsDataFrame") 
sp::plot(grid)
```

::: box-dica2

- Cria um objeto `RasterLayer` baseado no **contorno geogr√°fico do Rio de Janeiro** (`contorno.rio`).

- `res = 50` define a **resolu√ß√£o da grade**: cada c√©lula do raster ter√° **50 metros por 50 metros**.

- Esse raster ainda **n√£o cont√©m valores** ‚Äî √© s√≥ uma grade espacial com a extens√£o e proje√ß√£o do contorno.

:::


### Krigagem

```{r, echo=T, echo=T, message=FALSE, warning=FALSE, results='hide'}
# Colocando os dados de chuva e o grid na mesma projecao
sp::proj4string(pluvio) = CRS(proj4string(contorno.rio))

# Executando a interpola√ß√£o espacial por krigagem 
# usando diferentes modelos de variograma.
mapa_chuva_lin <- krige(acumulado_24h ~1, pluvio, grid, model =lin.fit)
mapa_chuva_exp <- krige(acumulado_24h ~1, pluvio, grid, model =exp.fit)
mapa_chuva_gau <- krige(acumulado_24h ~1, pluvio, grid, model =gau.fit)
mapa_chuva_wav <- krige(acumulado_24h ~1, pluvio, grid, model =wav.fit)
```


```{r, echo=T, out.width= "100%"}
plot.lin <- plot(mapa_chuva_lin, main = "Modelo Linear")
plot.exp <- plot(mapa_chuva_exp, main = "Modelo Exponencial")
plot.gau <- plot(mapa_chuva_gau, main = "Modelo Gaussiano")
plot.wav <- plot(mapa_chuva_wav, main = "Modelo Wave")

```

```{r, echo=T, out.width= "90%"}
###############################
# Outra op√ß√£o de gerar o mapa:#
##############################

# Paleta personalizada: tons frios (azul/verde claro) para baixos, quente (vermelho) para altos
paleta_cor <- rev(viridis(100, option = "A"))  # op√ß√£o "A" = magma (vermelho escuro a amarelo claro)

# Op√ß√µes de paleta da fun√ß√£o viridis():
# option = "A"  ‚Üí magma     (preto ‚Üí roxo ‚Üí vermelho ‚Üí laranja ‚Üí amarelo claro)
# option = "B"  ‚Üí inferno   (preto ‚Üí vermelho ‚Üí laranja ‚Üí amarelo claro, com mais contraste)
# option = "C"  ‚Üí plasma    (roxo ‚Üí rosa ‚Üí laranja ‚Üí amarelo claro)
# option = "D"  ‚Üí viridis   (verde escuro ‚Üí azul ‚Üí roxo ‚Üí amarelo claro) [padr√£o]
# option = "E"  ‚Üí cividis   (azul acinzentado ‚Üí amarelo p√°lido, acess√≠vel para dalt√¥nicos)
# option = "F"  ‚Üí rocket    (roxo escuro ‚Üí rosa ‚Üí branco amarelado)
# option = "G"  ‚Üí mako      (azul escuro ‚Üí ciano ‚Üí verde-√°gua, tons frios)
# option = "H"  ‚Üí turbo     (azul ‚Üí verde ‚Üí amarelo ‚Üí laranja ‚Üí vermelho, vibrante estilo Google)


# Plots com a nova paleta
spplot(mapa_chuva_lin, "var1.pred", main = "Modelo Linear", col.regions = paleta_cor)
spplot(mapa_chuva_exp, "var1.pred", main = "Modelo Exponencial", col.regions = paleta_cor)
spplot(mapa_chuva_gau, "var1.pred", main = "Modelo Gaussiano", col.regions = paleta_cor)
spplot(mapa_chuva_wav, "var1.pred", main = "Modelo Wave", col.regions = paleta_cor)
```


### üîß Auto Krige 

A fun√ß√£o `autoKrige()` do pacote `automap` √© utilizada para realizar a krigagem de forma automatizada, combinando os passos de ajuste do variograma e interpola√ß√£o espacial em um √∫nico processo. Ela permite que o usu√°rio defina uma vari√°vel de interesse e as coordenadas espaciais associadas, e ent√£o calcula o variograma experimental, ajusta automaticamente (ou conforme especificado) um modelo te√≥rico de variograma ‚Äî como exponencial, gaussiano ou esf√©rico ‚Äî e executa a krigagem ordin√°ria sobre uma grade de predi√ß√£o. O resultado √© um objeto que cont√©m os valores interpolados, a vari√¢ncia da predi√ß√£o e os par√¢metros do modelo ajustado, o que facilita a gera√ß√£o de mapas e a an√°lise espacial de forma pr√°tica e eficiente, mesmo para usu√°rios com pouca familiaridade com o ajuste manual de variogramas.

```{r, echo=T, message=FALSE, warning=FALSE}
# Modelando
auto.krige = autoKrige(acumulado_24h~x+y, pluvio, grid, model = 'Exp')
summary(auto.krige)
```

::: box-dica2

- `acumulado_24h ~ x + y`: f√≥rmula indicando que ser√° feito um modelo espacial com base nas coordenadas x e y para a vari√°vel de interesse acumulado_24h (precipita√ß√£o).

- `pluvio`: dados observados de precipita√ß√£o (classe SpatialPointsDataFrame).

- `grid`: grade de predi√ß√£o (onde queremos estimar os valores).

- `modelmodel = "Exp"`: especifica o tipo de modelo de variograma a ser ajustado ‚Äî neste caso, exponencial.
:::

```{r, echo=T, message=FALSE, warning=FALSE}
# Valida√ß√£o cruzada
auto.krige.cv <- autoKrige.cv(acumulado_24h~x+y, pluvio, model = 'Exp')
summary(auto.krige.cv)
```

### Convertendo para o formato raster - auto krige

```{r, echo=T, echo=T, message=FALSE, warning=FALSE}
raster_chuva <- raster(auto.krige$krige_output)
plot(raster_chuva)
```
```{r, echo=T, echo=T, message=FALSE, warning=FALSE}
# Outra op√ß√£o de plotar o raster
sp::spplot(auto.krige$krige_output, "var1.pred", main = "AutoKrige - Modelo Exponencial")

```

- Caso queira salvar a imagem raster em um arquivo formato geotiff para ler em algum SIG por exemplo:
  
```{r, echo=T, message=FALSE, warning=FALSE}
# Exportando o objeto da imagem
writeRaster(raster_chuva,
            filename = 'dados/chuva_rio/chuva_auto.tiff',
            format = 'GTiff',
            overwrite = T)

# Importando de volta para o R
raster_chuva <- raster("dados/chuva_rio/chuva_auto.tiff")
```

### üîç Fazendo o mapa interativo com as esta√ß√µes

```{r, echo=T, message=FALSE, warning=FALSE}
# 1. Importando e transformando as esta√ß√µes pluviom√©tricas
estacoes.sf <- read_sf("dados/chuva_rio/Estac_C3_B5es_Alerta_Rio.shp")
estacoes.longlat <- st_transform(estacoes.sf, 4326)  # EPSG:4326 = WGS84
estacoes.longlat$coords <- st_coordinates(estacoes.longlat)
estacoes.longlat$X <- estacoes.longlat$coords[, 1]
estacoes.longlat$Y <- estacoes.longlat$coords[, 2]
```

```{r, echo=T, message=FALSE, warning=FALSE}
# 2. Importando e transformando a malha de bairros
bairros.sf <- read_sf("dados/chuva_rio/BAIRROS_2K_2022_IPP_SIRGAS.shp")
bairros.longlat <- st_transform(bairros.sf, 4326)
bairros.longlat <- st_make_valid(bairros.longlat)  # Corrige geometrias se necess√°rio
```


```{r, echo=T, message=FALSE, warning=FALSE}
# 3. Convertendo o resultado da krigagem para raster
raster_chuva <- raster(auto.krige$krige_output["var1.pred"])

# 4. Projetando o raster para WGS84
raster_chuva_longlat <- projectRaster(raster_chuva, crs = CRS("+proj=longlat +datum=WGS84"))
```


```{r, echo=T, message=FALSE, warning=FALSE, results='hide'}
# 5. Definindo a paleta de cores da superf√≠cie interpolada
pal <- colorNumeric(
  palette = c("#000066", "#00c8f8", "#F0E68C", "#FFFF00", "#FF8C00"),
  domain = values(raster_chuva_longlat),
  na.color = "transparent",
  reverse = TRUE
)
```

```{r, echo=T, message=FALSE, warning=FALSE, out.width= "100%"}
# 6. Construindo o mapa interativo
leaflet(data = estacoes.longlat, options = leafletOptions(attributionControl = FALSE)) |>
  addProviderTiles("CartoDB.Positron", group = "Ruas") |>
  addProviderTiles("Esri.WorldImagery", options = providerTileOptions(opacity = 0.7), group = "Sat√©lite") |>
  addProviderTiles("CartoDB.Voyager", group = "Voyager") |>
  setView(lng = -43.42, lat = -22.90, zoom = 10.4) |>
  # Adicionando os marcadores das esta√ß√µes
  addMarkers(~X, ~Y, popup = ~as.character(est), label = ~as.character(est), group = "Esta√ß√µes") |>
  # Adicionando a malha de bairros
  addPolygons(data = bairros.longlat,
              weight = 3,
              color = "darkblue",
              smoothFactor = 1,
              fill = FALSE,
              labelOptions = labelOptions(
                style = list("font-weight" = "normal", padding = "3px 8px"),
                textsize = "13px",
                direction = "auto"),
              group = "Bairros") |>
  # Adicionando o raster de chuva interpolada
  addRasterImage(raster_chuva_longlat, colors = pal, opacity = 0.8, group = "Chuva: 1 semana") |>
  # Legenda
  addLegend(pal = pal, values = values(raster_chuva_longlat),
            title = "Chuva Acumulada - 1 semana",
            group = "Chuva: 1 semana") |>
  # Controle das camadas
  addLayersControl(
    baseGroups = c("Voyager", "Ruas", "Sat√©lite"),
    overlayGroups = c("Esta√ß√µes", "Bairros", "Chuva: 1 semana"),
    options = layersControlOptions(collapsed = FALSE),
    position = "bottomleft") |>
  # Oculta os bairros inicialmente
  hideGroup(group = c("Bairros"))
```



# Bibliografia sugerida

* Applied Spatial Statistics for Public Health Data; Lance A. Waller, Carol A. Gotway Wiley-Interscience 1St ed. 2004

* Applied Spatial Data Analysis with R; Roger S. Bivand, Edzer Pebesma , Virgilio Gomez-Rubio Springer; Edi√ß√£o: 2nd ed. 2013

* Cressie, N. (1993). Statistics for Spatial Data (Revised edition). New York: Wiley.

* Druck, S.; Carvalho, M.S.; C√¢mara, G.; Monteiro, A.V.M. (eds). [An√°lise Espacial de Dados Geogr√°ficos](http://www.dpi.inpe.br/gilberto/livro/analise/). Bras√≠lia, EMBRAPA, 2004.

* Fotheringham, A. S., Brunsdon, C., & Charlton, M. (2002). Geographically Weighted Regression: The Analysis of Spatially Varying Relationships. Wiley.

* Geocomputation with R by Robin Lovelace, Jakub Nowosad and Jannes Muenchow. [Geocomputation with R](https://geocompr.robinlovelace.net/), 2021.

* GeoComputation and Spatial Analysis practicals by Lex Comber
[On-line Book](https://bookdown.org/lexcomber/GEOG3195/)

* GEOG5917 Big Data & Consumer Analytics - RStudio Practicals by Lex Comber
[On-line Book](https://bookdown.org/lexcomber/GEOG5917/)

* Interactive Spatial Data Analysis by Trevor C. Bailey , Anthony C. Gatrell Routledge, 1995

* Spatial Statistics Workbook of Department of Criminology at the University of Manchester by Reka Solymosi and Juanjo Medina [Crime Mapping in R](https://maczokni.github.io/crime_mapping_textbook/)

* Spatial Data Science with R
[Spatial Data Science with R](https://rspatial.org/raster/index.html)




